<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Springboot中的yaml语法格式以及读取数据</title>
      <link href="/2022/08/07/springboot/Springboot%E4%B8%AD%E7%9A%84yaml%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/08/07/springboot/Springboot%E4%B8%AD%E7%9A%84yaml%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringBoot基础配置"><a href="#1-SpringBoot基础配置" class="headerlink" title="1.SpringBoot基础配置"></a>1.SpringBoot基础配置</h1><p>SpringBoot没有具体的功能，它在辅助加快Spring程序的开发效率,但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。</p><ul><li><strong>第一是pom.xml文件，设置项目的依赖</strong></li><li><strong>第二是引导类，这个是执行SpringBoot程序的入口</strong></li><li><strong>第三是在resources目录下面有一个空白的文件，叫做application.properties。（做配置的地方）</strong></li></ul><h2 id="1-1properties格式的文件属性配置"><a href="#1-1properties格式的文件属性配置" class="headerlink" title="1.1properties格式的文件属性配置"></a>1.1properties格式的文件属性配置</h2><p>SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的。<strong>（就是把8080改成80）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806193826532.png" alt="image-20220806193826532"></p><p>properties格式的文件书写规范是key&#x3D;value</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><p>意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。</p><p><strong>总结</strong></p><ul><li>SpringBoot默认配置文件是application.properties</li></ul><p>做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。</p><p><strong>关闭运行日志图表（banner)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure><p><strong>设置运行日志的显示级别</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.root</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure><p>我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。</p><p>打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>所有的starter中都会依赖下面这个starter，<strong>叫做spring-boot-starter</strong>。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>SpringBoot中导入对应starter后，提供对应配置属性</li><li>书写SpringBoot配置采用关键字+提示形式书写</li></ol><h2 id="1-2配置文件分类"><a href="#1-2配置文件分类" class="headerlink" title="1.2配置文件分类"></a>1.2配置文件分类</h2><p>SpringBoot相关的配置有properties格式，有没有更简便的配置格式提供给开发者使用。有吗？还真有。</p><ul><li><p>properties格式</p></li><li><p><strong>yml格式（主流格式）</strong></p></li><li><p>yaml格式</p></li><li><p>一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下</p></li><li><p>application.properties（properties格式）</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><ul><li>application.yml（yml格式）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><ul><li>application.yaml（yaml格式）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure><p><strong>配置文件优先级</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application.properties  &gt;  application.yml  &gt;  application.yaml</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>配置文件间的加载优先级properties（最高）&gt;  yml  &gt;  yaml（最低）</li><li>不同配置文件中相同配置按照加载优先级相互覆盖，<strong>不同配置文件中不同配置全部保留</strong></li></ol><p>如果找不到配置文件可以：指定SpringBoot配置文件</p><ul><li>Setting → Project Structure → Facets</li><li>选中对应项目&#x2F;工程</li><li>Customize Spring Boot</li><li>选择配置文件</li></ul><h2 id="1-3yaml文件（yaml语法格式）"><a href="#1-3yaml文件（yaml语法格式）" class="headerlink" title="1.3yaml文件（yaml语法格式）"></a>1.3yaml文件（yaml语法格式）</h2><p>SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。</p><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：</p><ul><li><strong>.yml格式（主流）</strong></li><li><strong>.yaml格式</strong></li></ul><p>语法格式要求具体如下：</p><ol><li>大小写敏感 （大小写区分）</li><li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li><li>使用缩进表示层级关系，同层级左侧对齐，<strong>只允许使用空格</strong>（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用<strong>冒号+空格</strong>作为分隔）<strong>（记得空格）</strong></li><li><strong>#号 表示注释</strong></li></ol><p><strong>但是idea有提示，熟悉就好了</strong></p><p>核心的一条规则要记住，<font color="#ff0000"><b>数据前面要加空格与冒号隔开</b></font></p><p>下面列出常见的数据书写格式，熟悉一下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">boolean:</span> <span class="literal">TRUE</span>  <span class="comment">#TRUE,true,True,FALSE,false，False均可</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span>    <span class="comment">#6.8523015e+5  #支持科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="number">123</span>       <span class="comment">#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制</span></span><br><span class="line"><span class="attr">null:</span> <span class="string">~</span>        <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="string">HelloWorld</span>      <span class="comment">#字符串可以直接书写</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;Hello World&quot;</span>  <span class="comment">#可以使用双引号包裹特殊字符</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-02-17</span>        <span class="comment">#日期必须使用yyyy-MM-dd格式</span></span><br><span class="line"><span class="attr">datetime:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment">#时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure><p>此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">likes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">music</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line"> <span class="comment">#上下这两个是相等的</span></span><br><span class="line"><span class="attr">likes:</span> [<span class="string">game</span>,<span class="string">music</span>,<span class="string">sleep</span>]</span><br></pre></td></tr></table></figure><p>​简单的一些用法</p><ul><li>&#96;&#96;&#96;yaml<br>subject:<ul><li><p>Java</p></li><li><p>前端</p></li><li><p>大数据<br>enterprise:<br>  name: itcast<br>  age: 16<br>  subject:</p><ul><li>Java</li><li>前端</li><li>大数据<br>likes: [王者荣耀,刺激战场]#数组书写缩略格式<br>users: #对象数组格式一</li></ul></li><li><p>name: Tom</p><p>   age: 4</p></li><li><p>name: Jerry<br>age: 5<br>users: #对象数组格式二</p></li><li><p>name: Tom<br>age: 4</p></li><li><p>name: Jerry<br>age: 5<br>users2: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ]#对象数组缩略格式</p></li></ul></li></ul><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    **总结**</span><br><span class="line">    </span><br><span class="line">    1. yaml语法规则</span><br><span class="line">       - 大小写敏感</span><br><span class="line">       - 属性层级关系使用多行描述，每行结尾使用冒号结束</span><br><span class="line">       - 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</span><br><span class="line">       - 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</span><br><span class="line">       - #号 表示注释</span><br><span class="line">    2. 注意属性名冒号后面与数据之间有一个**空格**</span><br><span class="line">    3. 字面值、对象数据格式、数组数据格式</span><br><span class="line"></span><br><span class="line"># 1.4yaml数据读取（这节看图理解）</span><br><span class="line"></span><br><span class="line">对于yaml文件中的数据，**不光能配置，同时也可以当一个小型的数据库**，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式</span><br><span class="line"></span><br><span class="line">### 1.4.1读取单一数据</span><br><span class="line"></span><br><span class="line">yaml中保存的单个数据，可以使用Spring中的注解直接读取，使用@Value可以读取单个数据，属性名引用方式：&lt;font color=&quot;#ff0000&quot;&gt;&lt;b&gt;$&#123;一级属性名.二级属性名……&#125;&lt;/b&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">这个是SpEL(Spring Expression Language)，即**Spring表达式语言**</span><br><span class="line"></span><br><span class="line">**\#&#123;…&#125;和$&#123;…&#125;区别**</span><br><span class="line"></span><br><span class="line">* **#&#123;…&#125; 用于执行SpEl表达式，并将内容赋值给属性**</span><br><span class="line"></span><br><span class="line">* **$&#123;…&#125; 主要用于加载外部属性文件中的值**</span><br><span class="line"></span><br><span class="line">* **\#&#123;…&#125; 和$&#123;…&#125; 可以混合使用，但是必须#&#123;&#125;外面，$&#123;&#125;在里面**</span><br><span class="line"></span><br><span class="line">![image-20220806210205501](https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806210205501.png)</span><br><span class="line"></span><br><span class="line">**记得使用@Value注解时，要将该注入写在某一个指定的Spring管控的bean的属性名上方。现在就可以读取到对应的单一数据行了,遇到数据就用中括号**</span><br><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">1. 使用@Value配合SpEL读取单个数据</span><br><span class="line">2. 如果数据存在多层级，依次书写层级名称即可</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**yaml数据读取引用属性**：</span><br><span class="line"></span><br><span class="line">![image-20220806212234972](https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806212234972.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.4.2读取全部数据</span><br><span class="line"></span><br><span class="line">读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做**Environment**，使用**自动装配注解（@Autowired ）**可以将所有的yaml数据封装到这个对象中</span><br><span class="line"></span><br><span class="line">![image-20220806212659549](https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806212659549.png)</span><br><span class="line"></span><br><span class="line">数据封装到了**Environment**对象中，获取属性时，通过Environment的接口操作进行，具体方法时getProperties（String），参数填写属性名即可</span><br><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">1. **使用Environment对象封装全部配置信息**</span><br><span class="line">2. **使用@Autowired自动装配数据到Environment对象中**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.4.3读取对象数据 （正常都是用这个，针对性的封装，主流模式）</span><br><span class="line"></span><br><span class="line">单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作</span><br><span class="line"></span><br><span class="line">**首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息，（操作步骤三步）。**</span><br><span class="line"></span><br><span class="line">1.定义数据模型封装yaml文件中对应的数据：**Enterprise类**</span><br><span class="line"></span><br><span class="line">2.定义为spirng管控的bean：**@Component**</span><br><span class="line"></span><br><span class="line">3.指定加载的数据：**@ConfigurationProperties**</span><br><span class="line"></span><br><span class="line">![image-20220806222315727](https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806222315727.png)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**@Component**：（把普通pojo实例化到spring容器中，相当于配置文件中的 &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;）泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。（受spring控制，才能由spring把数据给你）</span><br><span class="line"></span><br><span class="line">**@ConfigurationProperties**：Spring源码中大量使用了ConfigurationProperties注解，比如`server.port`就是由该注解获取到的，通过与其他注解配合使用，能够实现Bean的按需配置。该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，通过如下源码可以看出，该注解可以放在类上，也可以放在方法上。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这个**@ConfigurationProperties**必须告诉他加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。</span><br><span class="line"></span><br><span class="line">![image-20220806222419018](https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806222419018.png)</span><br><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">1. **使用@ConfigurationProperties注解绑定配置信息到封装类中**</span><br><span class="line">2. **封装类需要定义为Spring管理的bean，否则无法进行属性注入@Component**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.5**yaml文件中的数据引用：**</span><br><span class="line"></span><br><span class="line">​如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</span><br><span class="line"></span><br><span class="line">```YAML</span><br><span class="line">center:</span><br><span class="line">dataDir: /usr/local/fire/data</span><br><span class="line">    tmpDir: /usr/local/fire/tmp</span><br><span class="line">    logDir: /usr/local/fire/log</span><br><span class="line">    msgDir: /usr/local/fire/msgDir</span><br></pre></td></tr></table></figure></code></pre><p>或者</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line"><span class="attr">dataDir:</span> <span class="string">D:/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">D:/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">D:/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">D:/usr/local/fire/msgDir</span></span><br></pre></td></tr></table></figure><p>​这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baseDir:</span> <span class="string">/usr/local/fire</span></span><br><span class="line"><span class="attr">center:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">$&#123;baseDir&#125;/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">$&#123;baseDir&#125;/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">$&#123;baseDir&#125;/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">$&#123;baseDir&#125;/msgDir</span></span><br></pre></td></tr></table></figure><p>​还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lesson:</span> <span class="string">&quot;Spring\tboot\nlesson&quot;</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>在配置文件中可以使用${属性名}方式引用属性值</li><li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot基础介绍</title>
      <link href="/2022/08/06/springboot/Springboot%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/08/06/springboot/Springboot%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-快速上手SpringBoot"><a href="#1-快速上手SpringBoot" class="headerlink" title="1.快速上手SpringBoot"></a>1.快速上手SpringBoot</h1><ul><li><p>1.创建一个springboot项目（太简单了省略）</p></li><li><p>2.开发控制器类（基于Rest模式的开发控制器）–（建立一个controller层，新建BookController类）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rest模式</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;控制器会显示这行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;网页上会显示这行&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作<strong>SpringMVC</strong>的程序也是没有问题的，上例中的**@RestController与@GetMapping注解<strong>是基于</strong>Restful**开发的典型注解。（Restful是SpringMVC的知识）</p><ul><li>3.运行自动生成的Application类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220805195107855.png" alt="image-20220805195107855"></p><p>注意：Tomcat服务器没有配置，Spring也没有配置，什么都没有配置竟然能运行！这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程</p><p>注意这张图片信息：运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了</p><p><strong>访问路径</strong>：<a href="http://localhost:8080/books">http://localhost:8080/books</a></p><p>但是我们目前只能看到两个文件：<strong>pom.xml和Application类</strong>（pom.xml后面再说）</p><p><strong>Application类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。</p><p>通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spirng程序相比，SpringBoot程序在开发的过程中各个层面均具有优势。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220805200134419.png" alt="image-20220805200134419"></p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序可以根据向导进行联网快速制作</li><li>SpringBoot程序需要基于JDK8以上版本进行制作</li><li>SpringBoot程序中需要使用何种功能通过勾选选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li><li>运行SpringBoot程序通过运行Application程序入口进行</li></ol><h1 id="2-教你一招：在Idea中隐藏指定文件-x2F-文件夹（很实用）"><a href="#2-教你一招：在Idea中隐藏指定文件-x2F-文件夹（很实用）" class="headerlink" title="2.教你一招：在Idea中隐藏指定文件&#x2F;文件夹（很实用）"></a>2.教你一招：在Idea中隐藏指定文件&#x2F;文件夹（很实用）</h1><p>创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的<strong>SpringBoot工程文件结构</strong>。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p><p>处理方案无外乎两种，如果你对每一个文件&#x2F;目录足够了解，没有用的完全可以删除掉，或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。<strong>（要么删要么隐藏）</strong></p><ul><li><p>打开设置，【Files】→【Settings】</p></li><li><p>打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示（我用的是中文版都一样）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220805200848536.png" alt="image-20220805200848536"></p><ul><li>添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可。到这里就做完了，其实就是Idea的一个小功能。</li></ul><p><strong>总结</strong>：Idea中隐藏指定文件或指定类型文件</p><ol><li>【Files】→【Settings】</li><li>【Editor】→【File Types】→【Ignored Files and Folders】</li><li>输入要隐藏的名称，支持*号通配符</li><li>回车确认添加</li></ol><h1 id="3-SpringBoot简介"><a href="#3-SpringBoot简介" class="headerlink" title="3.SpringBoot简介"></a>3.SpringBoot简介</h1><h2 id="3-1Springboot介绍"><a href="#3-1Springboot介绍" class="headerlink" title="3.1Springboot介绍"></a>3.1Springboot介绍</h2><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来<strong>简化Spring应用的初始搭建以及开发过程</strong>。</p><p>说到springboot，其实就是对spring进行了简化。</p><hr><ul><li><strong>Spring程序缺点：</strong></li></ul><p><strong>1.依赖设置繁琐</strong>：以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标时必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定。</p><p><strong>2.配置繁琐：</strong>以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用</p><ul><li><strong>SpringBoot程序的核心功能及优点：</strong></li></ul><p><strong>1.起步依赖（简化依赖配置）：</strong>依赖配置的书写简化就是靠这个起步依赖达成的</p><p><strong>2.自动配置（简化常用工程相关配置）：</strong>配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说</p><p><strong>3.辅助功能（内置服务器，……）：</strong>除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot程序的一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了</p><hr><p>​下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面</p><ul><li><strong>parent</strong></li><li><strong>starter</strong></li><li><strong>引导类</strong></li><li><strong>内嵌tomcat</strong></li></ul><h2 id="3-2parent（类似一个规则）"><a href="#3-2parent（类似一个规则）" class="headerlink" title="3.2parent（类似一个规则）"></a>3.2<strong>parent</strong>（类似一个规则）</h2><p>SpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版与B技术的3.5版可以合作在一起，但是和B技术的3.7版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p><h2 id="3-3starter（类似一个组合）"><a href="#3-3starter（类似一个组合）" class="headerlink" title="3.3starter（类似一个组合）"></a>3.3starter（类似一个组合）</h2><p>SpringBoot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p><p>SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p><h2 id="3-4starter与parent的区别（这两个都是配置）"><a href="#3-4starter与parent的区别（这两个都是配置）" class="headerlink" title="3.4starter与parent的区别（这两个都是配置）"></a>3.4<strong>starter与parent的区别</strong>（这两个都是配置）</h2><p>朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p><p><strong>parent</strong>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的</p><p><strong>starter</strong>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的</p><p><strong>个人理解（大白话）：</strong>比如一个矿泉水瓶，由瓶子和水组成，<strong>parent</strong>相当于定义500ml的瓶子，和500ml的水，正好装满，别人600ml的水就多了。（减少依赖冲突）<strong>starter</strong>相当于直接到超市买了一瓶水，瓶子和水已经是正好合适的。（减少依赖配置的书写量）</p><p><strong>实际开发应用方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220805203316935.png" alt="image-20220805203316935"></p><p>​SpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命名规则：spring-boot-starter-技术名称</span><br></pre></td></tr></table></figure><p>​所以以后见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合章节再说</p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到<strong>简化配置</strong>的目的</li></ol><h2 id="3-5引导类（推导bean）"><a href="#3-5引导类（推导bean）" class="headerlink" title="3.5引导类（推导bean）"></a>3.5引导类（推导bean）</h2><p>配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类了，<strong>带有main方法的那个类</strong>，运行这个类就可以启动SpringBoot工程的运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。那SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot0101QuickstartApplication</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">        <span class="type">BookController</span> <span class="variable">bean</span> <span class="operator">=</span> ctx.getBean(BookController.class);<span class="comment">//拿bean有四种类型，getbean我们这次按类型拿，分别有1.名字2.类型3.名字+类型4.名字+赋值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bean======&gt;&quot;</span> + bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。这个类在SpringBoot程序中是所有功能的入口，称这个类为<strong>引导类</strong></p><p>​作为一个引导类最典型的特征就是当前类上方声明了一个注解**@SpringbootApplication**</p><p><strong>总结</strong></p><ol><li>SpringBoot工程提供引导类用来启动程序</li><li>SpringBoot工程启动后创建并初始化Spring容器</li></ol><p><strong>思考</strong></p><p>​程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？</p><h2 id="3-6内嵌tomcat"><a href="#3-6内嵌tomcat" class="headerlink" title="3.6内嵌tomcat"></a>3.6内嵌tomcat</h2><p>当前我们做的SpringBoot入门案例勾选了Spirng-web的功能，并且导入了对应的starter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西。我帮你搞一个web服务器，你要愿意用的，直接使用就好了，干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。</p><p>由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。</p><p>下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题</p><ol><li>这个服务器在什么位置定义的</li><li>这个服务器是怎么运行的</li><li>这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾</li></ol><h3 id="3-6-1内嵌Tomcat定义位置"><a href="#3-6-1内嵌Tomcat定义位置" class="headerlink" title="3.6.1内嵌Tomcat定义位置"></a>3.6.1<strong>内嵌Tomcat定义位置</strong></h3><p>说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。</p><p>说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>//点击这行</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​打开查看web的starter导入了哪些东西</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>//点击这行</span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>//看这行</span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里面有一个核心的坐标，<strong>tomcat-embed-core</strong>，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？<strong>spring-boot-starter-web中的spring-boot-starter-tomcat做的</strong>。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的</p><h3 id="3-6-2内嵌Tomcat运行原理"><a href="#3-6-2内嵌Tomcat运行原理" class="headerlink" title="3.6.2内嵌Tomcat运行原理"></a>3.6.2内嵌Tomcat运行原理</h3><p>Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉的小伙伴可能有印象，tomcat安装目录中保存有jar，好多个jar。</p><p>下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。</p><p>如果是对象，那Spring容器是用来管理对象的，这个对象能不能交给Spring容器管理呢？把呢去掉，是个对象都可以交给Spring容器管理，行了，这下通了。tomcat服务器运行其实是以对象的形式在Spring容器中运行的，怪不得我们没有安装这个tomcat，而且还能用。闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个<strong>tomcat内嵌核心</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>//tomcat内嵌核心</span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能。<strong>不要的东西都可以用exclusions排除掉</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>//不要的东西都可以用exclusions排除掉</span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。</p><p><strong>更换内嵌Tomcat</strong></p><p>​那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器</p><ul><li><p>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</p></li><li><p>jetty：更轻量级，负载性能远不及tomcat</p></li><li><p>undertow：负载性能勉强跑赢tomcat</p><p>想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。</p><p><strong>总结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li><li><strong>Tomcat内嵌三款服务器：tomacat、jetty、undetow（小知识）</strong></li></ol><p><strong>大白话总结：</strong>我们在依赖里加了<exclusions>（排除），把这个tomcat类似踢出去了。不要这个服务器了。但是还有备胎。不止一个服务器。我们再复制tomacat 的代码。把tomacat换成其他的服务器，比如jetty服务器，这样就可以去除现有服务器，添加全新的服务器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识</p><ol><li>使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的</li><li>学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等</li></ol><p>第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。</p><h1 id="4-REST开发（SpringMVC的知识）"><a href="#4-REST开发（SpringMVC的知识）" class="headerlink" title="4.REST开发（SpringMVC的知识）"></a>4.REST开发（SpringMVC的知识）</h1><h2 id="4-1REST简介"><a href="#4-1REST简介" class="headerlink" title="4.1REST简介"></a>4.1REST简介</h2><p>REST（Representational State Transfer）表现形态状态转换</p><ul><li><p>传统风格资源描述形式（比如查一个用户的信息）</p><p><a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a>   &#x2F;&#x2F;问号传个id为1得到信息</p><p><a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a> &#x2F;&#x2F;现在对资源做个保存，就可以通过post提交，把表单提交给后台，也可以对资源进行操作，注意get和save。</p></li><li><p>REST风格描述形式</p><p><a href="http://localhost/user/1">http://localhost/user/1</a>   &#x2F;&#x2F;比第一个简化好多，User资源id是1</p><p><a href="http://localhost/user">http://localhost/user</a>      &#x2F;&#x2F;有人就奇怪了，这怎么能代表保存呢，因为通过post提交，外面看不到这个数据了。既保存又能修改。</p></li></ul><p>优点：</p><ul><li><strong>隐藏资源的访问行为</strong>，无法通过地址得知对资源是何种操作（重要）</li><li>书写简化</li></ul><h2 id="4-2REST风格简介"><a href="#4-2REST风格简介" class="headerlink" title="4.2REST风格简介"></a>4.2REST风格简介</h2><p>按照<strong>REST风格</strong>访问资源时使用<strong>行为动作区</strong>分对资源进行了何种操作</p><ul><li><p><a href="http://localhost/users">http://localhost/users</a>    &#x2F;&#x2F;查询全部用户信息      GET（查询）</p></li><li><p><a href="http://localhost/user/1">http://localhost/user/1</a>  &#x2F;&#x2F;查询指定用户信息       GET（查询）  </p></li><li><p><a href="http://localhost/users">http://localhost/users</a>    &#x2F;&#x2F;添加用户信息             POST（新增&#x2F;保存）</p></li><li><p><a href="http://localhost/users">http://localhost/users</a>    &#x2F;&#x2F;修改用户信息             PUT（修改&#x2F;更新）</p></li><li><p><a href="http://localhost/users/1">http://localhost/users/1</a> &#x2F;&#x2F; 删除用户信息            DELETE（删除）</p></li><li><ul><li>根据REST风格对资源进行访问称为<strong>RESTFUL</strong></li></ul></li></ul><p>1和3和4、2和5路径都是一样的，那我们怎么区分，就要看到后面的请求方式get、post、put、delete进行区分。</p><p><strong>注意事项</strong>：上述行为是约定方式，约定不是规范，可以打破，所以被称为REST风格，而不是REST规范，描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如：users、books、accounts….(类似一个指导思想，所以叫做风格，但经过长时间，风格也慢慢成了规范。)</p><p>总结： </p><h2 id="4-3REST案例"><a href="#4-3REST案例" class="headerlink" title="4.3REST案例"></a>4.3REST案例</h2><p>1.设定http请求动作（动词）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806143757682.png" alt="image-20220806143757682"></p><p>2.设定请求参数（路径变量）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806143837068.png" alt="image-20220806143837068"></p><h2 id="4-4注解"><a href="#4-4注解" class="headerlink" title="4.4注解"></a>4.4注解</h2><p><strong>@RequstMapping</strong></p><ul><li>名称：**@RequstMapping**</li><li>类型：<strong>方法注解</strong></li><li>位置：SpringMVC控制器方法定义上方</li><li>作用：设置当前控制器方法<strong>请求访问路径</strong></li><li>范例：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806144341307.png" alt="image-20220806144341307"></p><ul><li>属性：</li><li><ul><li><strong>value（默认）：请求访问路径</strong></li><li><strong>method：http请求动作，标准动作（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）</strong></li></ul></li></ul><p> <strong>@PathVariable</strong></p><ul><li>名称：**@PathVariable**</li><li>类型：<strong>形参注解</strong></li><li>位置：SpringMVC控制器方法形参定义前面</li><li>作用：<strong>绑定路径参数与处理器方法形参间的关系</strong>，要求路径参数名一一对应</li><li>范例：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806144814631.png" alt="image-20220806144814631"></p><h2 id="4-5-RequestBody、-RequestParam、-RequestParam关系（接收参数三种方式）"><a href="#4-5-RequestBody、-RequestParam、-RequestParam关系（接收参数三种方式）" class="headerlink" title="4.5@RequestBody、@RequestParam、@RequestParam关系（接收参数三种方式）"></a>4.5@RequestBody、@RequestParam、@RequestParam关系（接收参数三种方式）</h2><p><strong>@RequestBody：****接我们请求体参数，也就是json用它来传</strong></p><p><strong>@RequestParam：</strong>接我们路径参数，包括表单提交都用它</p><p><strong>@PathVariable：</strong>接我们路径变量的</p><p><strong>区别：</strong></p><ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用（参数名称）描述路径参数</li></ul><p><strong>应用：</strong></p><ul><li>后期开发中，发送请求参数超过1个小时，以json为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul><h2 id="4-6RESTful快速开发（简化开发）"><a href="#4-6RESTful快速开发（简化开发）" class="headerlink" title="4.6RESTful快速开发（简化开发）"></a>4.6RESTful快速开发（简化开发）</h2><p> <strong>@RestController</strong></p><ul><li>名称：<strong>RestController</strong></li><li>类型：<strong>类注解</strong></li><li>位置：基于SpringMVC的RESTful开发控制器类定义上方</li><li>作用：设置当前控制器类为RESTful风格，等于@Controller+@ResponseBody两个注解组合功能</li><li>范例：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220806150805895.png" alt="image-20220806150805895"></p><ul><li>属性<ul><li>value(默认)：请求访问路径</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客添加 Live2d 小人</title>
      <link href="/2022/06/05/Hexo%20%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%20Live2d%20%E5%B0%8F%E4%BA%BA/"/>
      <url>/2022/06/05/Hexo%20%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%20Live2d%20%E5%B0%8F%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客添加-Live2d-小人"><a href="#Hexo-博客添加-Live2d-小人" class="headerlink" title="Hexo 博客添加 Live2d 小人"></a>Hexo 博客添加 Live2d 小人</h1><h3 id="一、安装hexo-helper-live2d插件"><a href="#一、安装hexo-helper-live2d插件" class="headerlink" title="一、安装hexo-helper-live2d插件"></a>一、安装hexo-helper-live2d插件</h3><p>**现在假设你已经又一个使用<code>hexo</code>搭建的博客，然后我们安装<a href="https://github.com/EYHN/hexo-helper-live2d">hexo-helper-live2d</a>模块</p><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">hexo-helper-live2d官方中文文档</a></p><blockquote><p>npm install –save hexo-helper-live2d</p></blockquote><h3 id="二、添加配置文件"><a href="#二、添加配置文件" class="headerlink" title="二、添加配置文件"></a>二、添加配置文件</h3><p>在<code>hexo</code>博客到<code>_config.yml</code>文件添加以下配置 建议在根目录下的<code>_config.yml</code>配置，这样以后换了主题就不用重新配置了 当然也可以在<code>themes</code>下的<code>_config.yml</code>配置但是要注意模型目录要填写正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">   enable: true  # 是否启动</span><br><span class="line">   scriptFrom: local # 默认</span><br><span class="line">   pluginRootPath: live2dw/  # 插件在站点上的根目录(相对路径)</span><br><span class="line">   pluginJsPath: lib/  # 脚本文件相对与插件根目录路径</span><br><span class="line">   pluginModelPath: assets/  # 模型文件相对与插件根目录路径</span><br><span class="line">   tagMode: false  # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">   debug: false  # 调试, 是否在控制台输出日志</span><br><span class="line">   model:</span><br><span class="line">     use: live2d-widget  ## 模型文件</span><br><span class="line">   display:</span><br><span class="line">     position: right # 定位方向 left right top bottom</span><br><span class="line">     width: 150  # 小人宽度</span><br><span class="line">     height: 300 #  小人高度</span><br><span class="line">     hOffset: -15  # 向</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew介绍</title>
      <link href="/2022/04/05/homebrew%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/05/homebrew%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E3%80%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="homebrew安装、卸载、基本操作"><a href="#homebrew安装、卸载、基本操作" class="headerlink" title="homebrew安装、卸载、基本操作"></a>homebrew安装、卸载、基本操作</h1><h2 id="一、Homebrew是什么？Homebrew的安装和使用"><a href="#一、Homebrew是什么？Homebrew的安装和使用" class="headerlink" title="一、Homebrew是什么？Homebrew的安装和使用"></a>一、Homebrew是什么？Homebrew的安装和使用</h2><p>**Homebrew ** 是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p><h3 id="1-1名词概念"><a href="#1-1名词概念" class="headerlink" title="1.1名词概念"></a>1.1名词概念</h3><p><strong>brew</strong>（意为酿酒）的命名很有意思，全部都使用了酿酒过程中采用的材料&#x2F;器具，名词对应以下的概念：</p><p><strong>Tap</strong> （水龙头）程序包的源</p><p><strong>Bottle</strong> （瓶子）编译打包好的程序包</p><p><strong>Formula</strong>（配方） 程序包定义，本质上是一个rb文件.代指软件包名,如git(实际操作: brew install git)</p><p><strong>Keg</strong> （桶）程序包的安装路径</p><p><strong>Cellar</strong> （地窖）所有程序包（桶）的根目录</p><p>最终编译安装完毕的程序就是一桶酿造好的酒。</p><h3 id="二、brew-安装脚本-（自动选择软件源）"><a href="#二、brew-安装脚本-（自动选择软件源）" class="headerlink" title="二、brew 安装脚本 （自动选择软件源）"></a>二、brew 安装脚本 （自动选择软件源）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="三、brew-卸载脚本"><a href="#三、brew-卸载脚本" class="headerlink" title="三、brew 卸载脚本"></a>三、brew 卸载脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h3><p>安装软件：<code>brew install xxx</code></p><p>卸载软件：<code>brew uninstall xxx</code></p><p>搜索软件：<code>brew search xxx</code></p><p>更新软件：<code>brew upgrade xxx</code></p><p>查看列表：<code>brew list</code></p><p>更新brew：<code>brew update</code></p><p>清理所有包的旧版本：<code>brew cleanup</code></p><p>清理指定包的旧版本：<code>brew cleanup $FORMULA</code></p><p>查看可清理的旧版本包，不执行实际操作：<code>brew cleanup -n</code></p><p>本地软件库列表：brew ls</p><p>查找软件：brew search google（其中google替换为要查找的关键字）</p><p>查看brew版本：brew -v 更新brew版本：brew update</p><p>安装cask软件：brew install –cask firefox 把firefox换成你要安装的</p>]]></content>
      
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库</title>
      <link href="/2021/05/15/mysql/Mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/2021/05/15/mysql/Mysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Mysql数据库"><a href="#1-Mysql数据库" class="headerlink" title="1.Mysql数据库"></a>1.Mysql数据库</h1><h2 id="1-1数据库的概念"><a href="#1-1数据库的概念" class="headerlink" title="1.1数据库的概念"></a>1.1数据库的概念</h2><p>是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</p><p>而程序员的工作就是对数据的管理，包括运算、流转、存储、展示等，数据库的最重要的功能就是【存储数据】，绝大部分的数据需要进行持久化，长期保存。</p><h2 id="1-2mysql介绍"><a href="#1-2mysql介绍" class="headerlink" title="1.2mysql介绍"></a>1.2mysql介绍</h2><p>MySQL是一种关系型数据库管理系统。</p><h2 id="1-3数据库"><a href="#1-3数据库" class="headerlink" title="1.3数据库"></a>1.3数据库</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。在mysql中可以创建多个数据库，一个数据库可以管理很多张表。</p><p>例如execl中的一个execl文件就是一个数据库，一个sheet页就是一张表，表里边可以有所需要的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220712133958527.png" alt="image-20220712133958527"></p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><h2 id="2-1SQL语句分类"><a href="#2-1SQL语句分类" class="headerlink" title="2.1SQL语句分类"></a>2.1SQL语句分类</h2><ul><li>DCL(Data Control Language)：数据控制语言，用来定义访问权限和安全级别。(不重要)–通过图形界面就能控制</li><li>DDL(Data Definition Language)：数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。(不重要)</li><li>DML(Data Manipulation Language)：数据操作语言，用来定义数据库记录：增、删、改表记录。(重要)</li><li>DQL(Data Query Language)：数据查询语言，用来查询记录。(重要)</li></ul><h2 id="2-2DCL-数据控制语言-语法（不重要）"><a href="#2-2DCL-数据控制语言-语法（不重要）" class="headerlink" title="2.2DCL(数据控制语言)语法（不重要）"></a>2.2DCL(数据控制语言)语法（不重要）</h2><p>该语言用来定义【访问权限和安全级别】，理解即可，直接使用命令控制权限的场景不多，更多情况是使用图形化界面进行操作。</p><h3 id="2-2-1-创建用户"><a href="#2-2-1-创建用户" class="headerlink" title="2.2.1. 创建用户"></a>2.2.1. 创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ydl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-修改密码："><a href="#2-2-2-修改密码：" class="headerlink" title="2.2.2.修改密码："></a>2.2.2.修改密码：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;ydl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;ydlclass&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果直接修改表，也是可以创建用户修改密码的，【mysql数据库下的user表】但是通过修改数据库创建用户，修改密码，都需要刷新权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="2-2-3给用户授权"><a href="#2-2-3给用户授权" class="headerlink" title="2.2.3给用户授权"></a>2.2.3给用户授权</h3><ul><li>create：可以常见数据库</li><li>select：可以查询数据</li><li>delete：可以删除数据</li><li>update：可以更新数据</li><li>insert：可以插入数据</li></ul><h2 id="2-3DDL-数据定义语言-语法-重要"><a href="#2-3DDL-数据定义语言-语法-重要" class="headerlink" title="2.3DDL(数据定义语言)语法(重要)"></a>2.3DDL(数据定义语言)语法(重要)</h2><p>DDL主要是用在定义或改变表（TABLE）的结构，主要的命令有CREATE、ALTER、DROP等：</p><h3 id="2-3-1创建表的基本语法"><a href="#2-3-1创建表的基本语法" class="headerlink" title="2.3.1创建表的基本语法"></a>2.3.1创建表的基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (</span><br><span class="line"></span><br><span class="line">字段名<span class="number">1</span>（列名） 类型(宽度) 约束条件,</span><br><span class="line"></span><br><span class="line">字段名<span class="number">2</span> 类型(宽度) 约束条件,</span><br><span class="line"></span><br><span class="line">字段名<span class="number">3</span> 类型(宽度) 约束条件,</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="2-3-2常用的数据类型"><a href="#2-3-2常用的数据类型" class="headerlink" title="2.3.2常用的数据类型"></a>2.3.2常用的数据类型</h2><ul><li>整型:在整形中我们默认使用的都是【有符号】的，当然了，我们也可以加上unsigned关键字，定义成无符号的类型，那么对应的取值范围就会发生改变：tinyint unsigned的取值范围为0~255.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220712141105607.png" alt="image-20220712141105607"></p><ul><li>浮点型:可以表示很大的数，也可以表示很小的数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220712141333050.png" alt="image-20220712141333050"></p><p>我们使用一个例子来判断小括号内参数的含义，针对数据类型为float(5, 3)的列，案例：</p><ul><li>插入123.45678，最后查询得到的结果为99.999；</li><li>插入12.34567，最后查询结果为12.346；</li></ul><p>所以，在使用浮点型的时候，还是要注意陷阱的，要以插入数据库中的实际结果为准。</p><ul><li>字符串数据类型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220712141549117.png" alt="image-20220712141549117"></p><h2 id="2-4DML-数据操作语言-语法（重要）"><a href="#2-4DML-数据操作语言-语法（重要）" class="headerlink" title="2.4DML(数据操作语言)语法（重要）"></a>2.4DML(数据操作语言)语法（重要）</h2><p>DML主要是对数据进行增（insert）删（delete）改（update）操作。</p><ul><li><h3 id="2-4-1添加数据"><a href="#2-4-1添加数据" class="headerlink" title="2.4.1添加数据"></a>2.4.1<strong>添加数据</strong></h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220716195217309.png" alt="image-20220716195217309"></p><p>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);</p><p>INSERT INTO 表名 VALUES(值1,值2,…);(但是不建议省略，看不清相互对应的关系)</p><p>INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;<br>INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;</p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 给指定列添加数据</span><br><span class="line">INSERT INTO stu (id, NAME) VALUES (1, &#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line">-- 给所有列添加数据，列名的列表可以省略的</span><br><span class="line">INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);</span><br><span class="line"></span><br><span class="line">INSERT INTO stu VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);</span><br><span class="line"></span><br><span class="line">-- 批量添加数据</span><br><span class="line">INSERT INTO stu VALUES </span><br><span class="line">(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1),</span><br><span class="line">(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1),</span><br><span class="line">(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);</span><br></pre></td></tr></table></figure><ul><li><h3 id="2-4-2修改数据"><a href="#2-4-2修改数据" class="headerlink" title="2.4.2修改数据"></a>2.4.2<strong>修改数据</strong></h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ;</span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>修改语句中如果不加条件，则将所有数据都修改！</li><li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li></ol><p>案例</p><p>将张三的性别改为女</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update stu set sex = &#x27;女&#x27; where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将张三的生日改为 1999-12-12 分数改为99.99</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update stu set birthday = &#x27;1999-12-12&#x27;, score = 99.99 where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多行的用逗号隔开就好了</p><p><strong>注意：如果update语句没有加where条件，则会将表中所有数据全部修改！</strong></p><ul><li><h3 id="2-4-3删除数据"><a href="#2-4-3删除数据" class="headerlink" title="2.4.3删除数据"></a>2.4.3删除数据</h3></li></ul><p> <strong>删除数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件] ;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 删除张三记录</span><br><span class="line">delete from stu where name = &#x27;张三&#x27;;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中所有的数据</span><br><span class="line">delete from stu;</span><br></pre></td></tr></table></figure><h1 id="3-DQL数据查询语言（重要）"><a href="#3-DQL数据查询语言（重要）" class="headerlink" title="3.DQL数据查询语言（重要）"></a>3.DQL数据查询语言（重要）</h1><p>页面上展示的数据肯定是在数据库中的试题库表中进行存储，而我们需要将数据库中的数据查询出来并展示在页面给用户看。页面上还会有分页展示的效果。数据库查询操作也是最重要的操作，所以此部分需要重点掌握。</p><ul><li>查询的完整语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    字段列表</span><br><span class="line">FROM </span><br><span class="line">    表名列表 </span><br><span class="line">WHERE </span><br><span class="line">    条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">    分组字段</span><br><span class="line">HAVING</span><br><span class="line">    分组后条件</span><br><span class="line">ORDER BY</span><br><span class="line">    排序字段</span><br><span class="line">LIMIT</span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220716202504341.png" alt="image-20220716202504341"></p><p>分为五个点来说：基础查询、条件查询、分组查询、排序查询、分页查询</p><p>前置案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表</span><br><span class="line">drop table if exists stu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 创建stu表</span><br><span class="line">CREATE TABLE stu (</span><br><span class="line"> id int, -- 编号</span><br><span class="line"> name varchar(20), -- 姓名</span><br><span class="line"> age int, -- 年龄</span><br><span class="line"> sex varchar(5), -- 性别</span><br><span class="line"> address varchar(100), -- 地址</span><br><span class="line"> math double(5,2), -- 数学成绩</span><br><span class="line"> english double(5,2), -- 英语成绩</span><br><span class="line"> hire_date date -- 入学时间</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO stu(id,NAME,age,sex,address,math,english,hire_date) </span><br><span class="line">VALUES </span><br><span class="line">(1,&#x27;马运&#x27;,55,&#x27;男&#x27;,&#x27;杭州&#x27;,66,78,&#x27;1995-09-01&#x27;),</span><br><span class="line">(2,&#x27;马花疼&#x27;,45,&#x27;女&#x27;,&#x27;深圳&#x27;,98,87,&#x27;1998-09-01&#x27;),</span><br><span class="line">(3,&#x27;马斯克&#x27;,55,&#x27;男&#x27;,&#x27;香港&#x27;,56,77,&#x27;1999-09-02&#x27;),</span><br><span class="line">(4,&#x27;柳白&#x27;,20,&#x27;女&#x27;,&#x27;湖南&#x27;,76,65,&#x27;1997-09-05&#x27;),</span><br><span class="line">(5,&#x27;柳青&#x27;,20,&#x27;男&#x27;,&#x27;湖南&#x27;,86,NULL,&#x27;1998-09-01&#x27;),</span><br><span class="line">(6,&#x27;刘德花&#x27;,57,&#x27;男&#x27;,&#x27;香港&#x27;,99,99,&#x27;1998-09-01&#x27;),</span><br><span class="line">(7,&#x27;张学右&#x27;,22,&#x27;女&#x27;,&#x27;香港&#x27;,99,99,&#x27;1998-09-01&#x27;),</span><br><span class="line">(8,&#x27;德玛西亚&#x27;,18,&#x27;男&#x27;,&#x27;南京&#x27;,56,65,&#x27;1994-09-02&#x27;);</span><br></pre></td></tr></table></figure><h2 id="3-1基础查询"><a href="#3-1基础查询" class="headerlink" title="3.1基础查询"></a>3.1基础查询</h2><p><strong>查询多个字段（多个列）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名;</span><br><span class="line">SELECT * FROM 表名; -- 查询所有数据</span><br><span class="line">--练习</span><br><span class="line">SELECT name,age FROM stu;</span><br></pre></td></tr></table></figure><p><strong>不同的记录，可以显示不同的数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="line">--练习</span><br><span class="line">SELECT DISTINCT address FROM stu;</span><br></pre></td></tr></table></figure><p><strong>起别名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS: AS 也可以省略</span><br></pre></td></tr></table></figure><p><strong>查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,math as 数学成绩,english as 英文成绩 from stu;</span><br><span class="line">select name,math 数学成绩,english 英文成绩 from stu;</span><br></pre></td></tr></table></figure><h2 id="3-2条件查询"><a href="#3-2条件查询" class="headerlink" title="3.2条件查询"></a>3.2条件查询</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220716204653119.png" alt="image-20220716204653119"></p><h3 id="3-2-1案例："><a href="#3-2-1案例：" class="headerlink" title="3.2.1案例："></a>3.2.1案例：</h3><ul><li><p>查询年龄大于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面语句中 &amp;&amp;  和  and  都表示并且的意思。建议使用 and 。</p><p>也可以使用  between … and 来实现上面需求</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;（用这个）</span><br></pre></td></tr></table></figure></li><li><p>查询入学日期在’1998-09-01’ 到 ‘1999-09-01’  之间的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> hire_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1998-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1999-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;（数据库不需要<span class="operator">=</span><span class="operator">=</span>）</span><br></pre></td></tr></table></figure></li><li><p>查询年龄不等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">18</span>;（用这个）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">20</span> ,<span class="number">22</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩为 null的学员信息</p><p>null值的比较不能使用 &#x3D;  或者 !&#x3D; 。需要使用 is  或者 is not</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="operator">=</span> <span class="keyword">null</span>; <span class="comment">-- 这个语句是不行的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-模糊查询练习"><a href="#3-2-2-模糊查询练习" class="headerlink" title="3.2.2 模糊查询练习"></a>3.2.2 模糊查询练习</h3><p>模糊查询使用like关键字，可以使用通配符进行占位:</p><p>（1）_ : 代表单个任意字符</p><p>（2）% : 代表任意个数字符</p><ul><li><p>查询姓’马’的学员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;马%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询第二个字是’花’的学员信息  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;_花%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>查询名字中包含 ‘德’ 的学员信息（用的最多）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3排序"><a href="#3-3排序" class="headerlink" title="3.3排序"></a>3.3排序</h2><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;</span><br></pre></td></tr></table></figure><p>上述语句中的排序方式有两种，分别是：</p><ul><li>ASC ： 升序排列 <strong>（默认值）</strong></li><li>DESC ： 降序排列</li></ul><blockquote><p><strong>注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</strong></p></blockquote><p><strong>案例：</strong></p><ul><li><p>查询学生信息，按照年龄升序排列 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> , english <span class="keyword">asc</span> ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-1聚合函数"><a href="#3-3-1聚合函数" class="headerlink" title="3.3.1聚合函数"></a>3.3.1聚合函数</h3><ul><li><strong>概念：</strong></li></ul><p> &#x3D;&#x3D;将一列数据作为一个整体，进行纵向计算。&#x3D;&#x3D;</p><p>比如求一列中的求和，最大值，最小值之类的。</p><ul><li><strong>聚合函数分类</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717141400064.png" alt="image-20220717141400064"></p><ul><li><strong>聚合函数语法：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数名(列名) FROM 表;</span><br></pre></td></tr></table></figure><p>注意：null 值不参与所有聚合函数运算</p><ul><li><p><strong>案例：</strong></p></li><li><p>统计班级一共有多少个学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> stu;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu;（常用）</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最高分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最低分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的总分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的平均分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩的最低分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4分组查询"><a href="#3-4分组查询" class="headerlink" title="3.4分组查询"></a>3.4分组查询</h2><ul><li><strong>语法：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 分组前条件限定] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><ul><li><p><strong>案例</strong></p></li><li><p>查询男同学和女同学各自的数学平均分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, avg <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><blockquote><p>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, sex, <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;  <span class="comment">-- 这里查询name字段就没有任何意义</span></span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4-1where-和-having-区别："><a href="#3-4-1where-和-having-区别：" class="headerlink" title="3.4.1where 和 having 区别："></a>3.4.1<strong>where 和 having 区别：</strong></h4><ul><li><p>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而<strong>having是分组之后对结果进行过滤。</strong></p></li><li><p>可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p></li></ul><p><strong>所有的都是在 SELECT * FROM 表名。都是在里面扩充。</strong></p><p><strong>执行顺序：where &gt; 聚合函数 &gt; having</strong></p><h2 id="3-5分页查询"><a href="#3-5分页查询" class="headerlink" title="3.5分页查询"></a>3.5分页查询</h2><p>分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。一页一页的看。而不是一次性都放出来。</p><ul><li><strong>语法</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><p><strong>注意： 上述语句中的起始索引是从0开始</strong></p><ul><li><p><strong>案例</strong></p></li><li><p>从0开始查询，查询3条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第1页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第2页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">3</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第3页数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">6</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><p>从上面的练习推导出起始索引计算公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始索引 <span class="operator">=</span> (当前页码 <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> 每页显示的条数</span><br></pre></td></tr></table></figure><p>简单概括一下：比如有八个数据，分成每页三个数据，那就3，3，2。第三页的值肯定是从第七个数开始，但是计算机序列是从0开始。那就减1.所以就解释了limit 6 , 3;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT  (当前页码 - 1) * 查询条目数 , 查询条目数;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql约束、设计、多表查询、事务</title>
      <link href="/2021/05/15/mysql/mysql%E7%BA%A6%E6%9D%9F%E3%80%81%E8%AE%BE%E8%AE%A1%E3%80%81%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E3%80%81%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/05/15/mysql/mysql%E7%BA%A6%E6%9D%9F%E3%80%81%E8%AE%BE%E8%AE%A1%E3%80%81%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E3%80%81%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-约束"><a href="#1-约束" class="headerlink" title="1.约束"></a>1.约束</h1><h2 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h2><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p><p>例如：<strong>不能为null值，不能不填。</strong></p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p><p>例如：<strong>不能瞎填数据，岁数为负。</strong></p></li></ul><h2 id="1-2分类"><a href="#1-2分类" class="headerlink" title="1.2分类"></a>1.2分类</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717183530749.png" alt="image-20220717183530749"></p><p>很简单字面意思。</p><h2 id="1-3约束练习"><a href="#1-3约束练习" class="headerlink" title="1.3约束练习"></a>1.3约束练习</h2><p>根据需求，为表添加合适的约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">id <span class="type">INT</span>,  <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">    ename <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 员工姓名，非空且唯一</span></span><br><span class="line">    joindate <span class="type">DATE</span>,  <span class="comment">-- 入职日期，非空</span></span><br><span class="line">    salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>),  <span class="comment">-- 工资，非空</span></span><br><span class="line">    bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>)  <span class="comment">-- 奖金，如果没有将近默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> 添加完</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,  <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 员工姓名，非空且唯一</span></span><br><span class="line">    joindate <span class="type">DATE</span> <span class="keyword">not</span> <span class="keyword">NULL</span>,  <span class="comment">-- 入职日期，非空</span></span><br><span class="line">    salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">NULL</span>,  <span class="comment">-- 工资，非空</span></span><br><span class="line">    bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span><span class="comment">-- 奖金，如果没有将近默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p><strong>auto_increment</strong></p><p>自动增长，当列是数字类型，并且唯一约束。</p></li></ul><h2 id="1-4外键约束"><a href="#1-4外键约束" class="headerlink" title="1.4外键约束"></a>1.4外键约束</h2><p>外键用来让两个表的数据直接建立链接，保证数据的一致性和完整性。（就是让两个表有关系）</p><ul><li><strong>添加外键约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键列名) <span class="keyword">REFERENCES</span> 主表(主表列名) </span><br><span class="line">); (常用这个 )</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br></pre></td></tr></table></figure><h3 id="1-4-1案例："><a href="#1-4-1案例：" class="headerlink" title="1.4.1案例："></a>1.4.1案例：</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717203954102.png" alt="image-20220717203954102"></p><p>1.根据上述语法创建员工表和部门表，并添加上外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> dept(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加 2 个部门</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加员工,dep_id 表示员工所在的部门</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>, <span class="number">20</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;孙七&#x27;</span>, <span class="number">22</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;周八&#x27;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">FOREIGN</span> key fk_emp_dept;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> key(dep_id) <span class="keyword">REFERENCES</span> dept(id);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717204458489.png" alt="image-20220717204458489"></p><p>navicat可以查看它们的关联。</p><h1 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717204655047.png" alt="image-20220717204655047"></p><h2 id="2-1数据库设计简介"><a href="#2-1数据库设计简介" class="headerlink" title="2.1数据库设计简介"></a>2.1数据库设计简介</h2><h3 id="2-1-1软件的研发步骤"><a href="#2-1-1软件的研发步骤" class="headerlink" title="2.1.1软件的研发步骤"></a>2.1.1软件的研发步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717205125907.png" alt="image-20220717205125907"></p><h3 id="2-1-2数据库设计概念"><a href="#2-1-2数据库设计概念" class="headerlink" title="2.1.2数据库设计概念"></a>2.1.2数据库设计概念</h3><p>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。建立数据库中的&#x3D;&#x3D;表结构&#x3D;&#x3D;以及&#x3D;&#x3D;表与表之间的关联关系&#x3D;&#x3D;的过程。</p><p><strong>简单来说就是有哪些表？表里有哪些字段？表和表之间有什么关系？</strong></p><h3 id="2-1-1数据库设计的步骤"><a href="#2-1-1数据库设计的步骤" class="headerlink" title="2.1.1数据库设计的步骤"></a>2.1.1数据库设计的步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717205314913.png" alt="image-20220717205314913"></p><h2 id="2-2表关系（三种）"><a href="#2-2表关系（三种）" class="headerlink" title="2.2表关系（三种）"></a>2.2表关系（三种）</h2><ul><li><strong>一对一：在任意一方建立外键，关联对方主键，并设置外键唯一。</strong></li><li><strong>一对多（多对一）:在多的一方建立外键，关联一的一方主键。</strong></li><li><strong>多对多:1.建立第三张中间表–2.中间表至少包含2个外键，分别关联双方主键。</strong></li></ul><h3 id="2-2-1一对一【用的少】"><a href="#2-2-1一对一【用的少】" class="headerlink" title="2.2.1一对一【用的少】"></a>2.2.1一对一【用的少】</h3><p>如：人 和 身份证。一个人对应一个身份证。</p><p><strong>作用：一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能****。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717213024694.png" alt="image-20220717213024694"></p><ul><li><strong>实现方式：</strong></li></ul><p>&#x3D;&#x3D;在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)&#x3D;&#x3D;</p><ul><li><strong>案例：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user_desc (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">edu <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">income <span class="type">int</span>,</span><br><span class="line">status <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">des <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">photo <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nickname <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">desc_id <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_user_desc <span class="keyword">FOREIGN</span> KEY(desc_id) <span class="keyword">REFERENCES</span> tb_user_desc(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-2-2一对多（多对一）【常见】"><a href="#2-2-2一对多（多对一）【常见】" class="headerlink" title="2.2.2一对多（多对一）【常见】"></a>2.2.2一对多（多对一）【常见】</h3><p>如：部门 和 员工。一个部门对应多个员工，一个员工对应一个部门。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717205956562.png" alt="image-20220717205956562"></p><ul><li><strong>实现方式：</strong></li></ul><p>直接添加一个外键就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717211906796.png" alt="image-20220717211906796"></p><p>经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：</p><p><strong>会在多的一方添加外键，用来指定主键。</strong></p><ul><li><strong>案例：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> tb_dept(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-2-3多对多"><a href="#2-2-3多对多" class="headerlink" title="2.2.3多对多"></a>2.2.3多对多</h3><p>如：商品 和 订单。一个商品对应多个订单，一个订单包含多个商品。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717210047223.png" alt="image-20220717210047223"></p><ul><li><strong>实现方式：</strong></li></ul><p>&#x3D;&#x3D;建立第三张中间表，中间表至少包含两个外键，分别关联两方主键&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717212449513.png" alt="image-20220717212449513"></p><ul><li><strong>案例：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order_goods;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_goods;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">payment <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">payment_type TINYINT,</span><br><span class="line">status TINYINT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">title <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单商品中间表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">order_id <span class="type">int</span>,</span><br><span class="line">goods_id <span class="type">int</span>,</span><br><span class="line">count <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后，添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_order_id <span class="keyword">FOREIGN</span> key(order_id) <span class="keyword">REFERENCES</span> tb_order(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_goods_id <span class="keyword">FOREIGN</span> key(goods_id) <span class="keyword">REFERENCES</span> tb_goods(id);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717212854820.png" alt="image-20220717212854820"></p><h1 id="3-多表查询："><a href="#3-多表查询：" class="headerlink" title="3.多表查询："></a>3.多表查询：</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220717215228193.png" alt="image-20220717215228193"></p><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建部门表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    did <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    dname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 创建员工表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    gender <span class="type">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">    salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">    join_date <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">    dep_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (dep_id) <span class="keyword">REFERENCES</span> dept(did) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加部门数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (dNAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;研发部&#x27;</span>),(<span class="string">&#x27;市场部&#x27;</span>),(<span class="string">&#x27;财务部&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 添加员工数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dep_id) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">7200</span>,<span class="string">&#x27;2013-02-24&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">3600</span>,<span class="string">&#x27;2010-12-02&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">9000</span>,<span class="string">&#x27;2008-08-08&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;白骨精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;2015-10-07&#x27;</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;蜘蛛精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">4500</span>,<span class="string">&#x27;2011-03-14&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;小白龙&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">2500</span>,<span class="string">&#x27;2011-02-14&#x27;</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>执行下面的多表查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept;  <span class="comment">-- 从emp和dept表中查询所有的字段数据</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718081119062.png" alt="image-20220718081119062"></p><p>从表中看有24条记录，那么明显是有问题的。取了笛卡尔积：有A、B两个集合，取A、B所有的组合情况。（所以数据大量重复）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp , dept where emp.dep_id = dept.did;</span><br></pre></td></tr></table></figure><p>可以通过这个语法来去除重复。</p><h2 id="3-1连接查询"><a href="#3-1连接查询" class="headerlink" title="3.1连接查询"></a>3.1连接查询</h2><ul><li><p><strong>内连接查询 ：相当于查询AB交集数据</strong></p></li><li><p><strong>外连接查询</strong></p><ul><li><strong>左外连接查询 ：相当于查询A表所有数据和交集部门数据</strong></li><li><strong>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</strong></li></ul></li><li><p><strong>子查询</strong></p></li></ul><h2 id="3-2内连接查询"><a href="#3-2内连接查询" class="headerlink" title="3.2内连接查询"></a>3.2内连接查询</h2><h3 id="3-2-1隐式内连接"><a href="#3-2-1隐式内连接" class="headerlink" title="3.2.1隐式内连接"></a>3.2.1隐式内连接</h3><ul><li><strong>概念：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span>… <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718082007602.png" alt="image-20220718082007602"></p><ul><li><strong>案例</strong></li></ul><p><strong>1.查询表的信息(所有的交集)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p><strong>2.查询表的部门信息(部分部门的信息交集)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.NAME,</span><br><span class="line">emp.gender,</span><br><span class="line">dept.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p><strong>3.上面语句中使用表名指定字段所属有点麻烦，sql也支持给表指别名，上述语句可以改进为</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t1. NAME,</span><br><span class="line">t1.gender,</span><br><span class="line">t2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t1.dep_id <span class="operator">=</span> t2.did;</span><br></pre></td></tr></table></figure><h3 id="3-2-2显式内连接"><a href="#3-2-2显式内连接" class="headerlink" title="3.2.2显式内连接"></a>3.2.2显式内连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br><span class="line"><span class="comment">-- 上面语句中的inner可以省略，可以书写为如下语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>区别：当只是两张表时，显示和隐式都可以使用，而当需要多张表进行内链接时，就必须使用显示内连接的格式了，如果使用隐式则会报错。。。</p><h2 id="3-3外连接查询"><a href="#3-3外连接查询" class="headerlink" title="3.3外连接查询"></a>3.3外连接查询</h2><h3 id="3-3-1语法"><a href="#3-3-1语法" class="headerlink" title="3.3.1语法"></a>3.3.1语法</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718083650607.png" alt="image-20220718083650607"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>左外连接：相当于查询A表所有数据和交集部分数据</strong></p><p><strong>右外连接：相当于查询B表所有数据和交集部分数据</strong></p><h3 id="3-3-2左外连接案例（常用）"><a href="#3-3-2左外连接案例（常用）" class="headerlink" title="3.3.2左外连接案例（常用）"></a>3.3.2左外连接案例（常用）</h3><p>查询emp表所有数据和对应的部门信息（左外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><h3 id="3-3-3右外连接案例"><a href="#3-3-3右外连接案例" class="headerlink" title="3.3.3右外连接案例"></a>3.3.3右外连接案例</h3><p>查询dept表所有数据和对应的员工信息（右外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><h3 id="3-3-4通用连接"><a href="#3-3-4通用连接" class="headerlink" title="3.3.4通用连接"></a>3.3.4通用连接</h3><p>一般我们用左外连接比较多，其实是因为用左外连接都可以实现，只需要将表位置进行互换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--左外连接</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br><span class="line"></span><br><span class="line"><span class="comment">--右外连接</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br><span class="line"></span><br><span class="line"><span class="comment">--两者只是把表进行了互换。也可以实现。</span></span><br></pre></td></tr></table></figure><h2 id="3-4子查询"><a href="#3-4子查询" class="headerlink" title="3.4子查询"></a>3.4子查询</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718084452304.png" alt="image-20220718084452304"></p><p>概念：子查询类似于复合查询，意思是本来可能需要两个表查询下，现在只需要整合用一个就可以了。</p><h3 id="3-4-1分类"><a href="#3-4-1分类" class="headerlink" title="3.4.1分类"></a>3.4.1分类</h3><p>子查询根据查询结果不同，作用不同</p><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 &#x3D;  !&#x3D;  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li></ul><h3 id="3-4-2子查询单行单列"><a href="#3-4-2子查询单行单列" class="headerlink" title="3.4.2子查询单行单列"></a>3.4.2子查询单行单列</h3><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 &#x3D;  !&#x3D;  &gt;  &lt;  等进行条件判断</li></ul><p>案例：</p><p>来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span></span><br></pre></td></tr></table></figure><p> 第二步：查询工资高于猪八戒的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="number">3600</span>;</span><br></pre></td></tr></table></figure><p>第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-4-3子查询多行单列"><a href="#3-4-3子查询多行单列" class="headerlink" title="3.4.3子查询多行单列"></a>3.4.3子查询多行单列</h3><p>案例</p><ul><li><p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门did</span></span><br><span class="line"><span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dep_id <span class="keyword">in</span> (<span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-5子查询多行多列"><a href="#3-4-5子查询多行多列" class="headerlink" title="3.4.5子查询多行多列"></a>3.4.5子查询多行多列</h3><ul><li><p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ;</span><br><span class="line"><span class="comment">-- 将上面语句的结果作为虚拟表和dept表进行内连接查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ) t1, dept <span class="keyword">where</span> t1.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul><p>意思是虽然可以多个表查询，但是每个表名称太长了。我们可以用个简称比如说“t1”简化一下。这样就方便多了。不至于显得太乱。</p><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h1><h2 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h2><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了&#x3D;&#x3D;一组数据库操作命令&#x3D;&#x3D;。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令</p><ul><li><strong>要么同时成功，要么同时失败</strong></li></ul><p>事务是一个不可分割的工作逻辑单元。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718121217210.png" alt="image-20220718121217210"></p><h2 id="4-2语法"><a href="#4-2语法" class="headerlink" title="4.2语法"></a>4.2语法</h2><ul><li><p><strong>开启事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>提交事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>回滚事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-代码验证"><a href="#4-3-代码验证" class="headerlink" title="4.3  代码验证"></a>4.3  代码验证</h2><ul><li>环境准备</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> account;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建账户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;李四&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>不加事务演示问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。</p><ul><li>添加事务sql如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h2 id="4-4-事务的四大特征"><a href="#4-4-事务的四大特征" class="headerlink" title="4.4  事务的四大特征"></a>4.4  事务的四大特征</h2><ul><li><p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p></li><li><p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p></li><li><p>隔离性（Isolation） :多个事务之间，操作的可见性</p></li><li><p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><p><strong>&#x3D;&#x3D;说明：&#x3D;&#x3D;</strong></p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @<span class="meta">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Servlet</title>
      <link href="/2021/05/07/java%20web/%E4%BA%86%E8%A7%A3Servlet/"/>
      <url>/2021/05/07/java%20web/%E4%BA%86%E8%A7%A3Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Web项目结构"><a href="#1-Web项目结构" class="headerlink" title="1.Web项目结构"></a>1.Web项目结构</h1><p>Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下:</p><ul><li><p>Maven Web项目结构: 开发中的项目</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/1627202865978.png" alt="1627202865978"></p></li><li><p>开发完成部署的Web项目</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/1627202903750.png" alt="1627202903750"></p><ul><li>开发项目通过执行Maven打包命令&#x3D;&#x3D;package&#x3D;&#x3D;,可以获取到部署的Web项目目录</li><li>编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下</li><li>pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下</li></ul></li></ul><h1 id="2-Servlet简介"><a href="#2-Servlet简介" class="headerlink" title="2.Servlet简介"></a>2.Servlet简介</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220720151346848.png" alt="image-20220720151346848"></p><ul><li><p>Servlet是JavaWeb最为核心的内容，它是Java提供的一门&#x3D;&#x3D;动态&#x3D;&#x3D;web资源开发技术。</p></li><li><p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。</p></li><li><p>Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220720151356866.png" alt="image-20220720151356866"></p><p>介绍完Servlet是什么以后，接下来我们就按照<code>快速入门</code>-&gt;<code>执行流程</code>-&gt;<code>生命周期</code>-&gt;<code>体系结构</code>-&gt;<code>urlPattern配置</code>-&gt;<code>XML配置</code>的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220720151430446.png" alt="image-20220720151430446"></p><h1 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h1><p>总共有 四个步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220720151850501.png" alt="image-20220720151850501"></p><p>步骤：1.创建Web项目<code>web-demo</code>，导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      此处为什么需要添加该标签?</span></span><br><span class="line"><span class="comment">      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置:在类上使用@WebServlet注解，配置该Servlet的访问路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>访问:启动Tomcat,浏览器中输入URL地址访问该Servlet</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure><ol start="5"><li>浏览器访问后，在控制台会打印<code>servlet hello world~</code> 说明servlet程序已经成功运行。</li></ol><p>至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。</p><h1 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4.执行流程"></a>4.执行流程</h1><p>Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了<code>servlet hello world~</code>这句话呢?</p><p>要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220720153518756.png" alt="image-20220720153518756"></p><ul><li>浏览器发出<code>http://localhost:8080/web-demo/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code><ul><li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li><li>根据<code>web-demo</code>可以找到部署在Tomcat服务器上的web-demo项目</li><li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li></ul></li><li>找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法<ul><li>ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li><li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li></ul></li></ul><p><strong>小结</strong></p><p>介绍完Servlet的执行流程，需要大家掌握两个问题：</p><ol><li>Servlet由谁创建?Servlet方法由谁调用?</li></ol><blockquote><p>Servlet由web服务器创建，Servlet方法由web服务器调用</p></blockquote><ol start="2"><li>服务器怎么知道Servlet中一定有service方法?</li></ol><blockquote><p>因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法</p></blockquote><h1 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h1><p>介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。</p><p>接下来咱们再来思考一个问题:&#x3D;&#x3D;Tomcat什么时候创建的Servlet对象?&#x3D;&#x3D;</p><p>要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。</p><ul><li><p>生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。</p></li><li><p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>&#x3D;&#x3D;加载和实例化&#x3D;&#x3D;：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?</span><br><span class="line"></span><br><span class="line">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span><br><span class="line">loadOnstartup的取值有两类情况</span><br><span class="line">（1）负整数:第一次访问时创建Servlet对象</span><br><span class="line">（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</span><br></pre></td></tr></table></figure><ol start="2"><li>&#x3D;&#x3D;初始化&#x3D;&#x3D;：在Servlet实例化之后，容器将调用Servlet的&#x3D;&#x3D;init()&#x3D;&#x3D;方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只&#x3D;&#x3D;调用一次&#x3D;&#x3D;</li><li>&#x3D;&#x3D;请求处理&#x3D;&#x3D;：&#x3D;&#x3D;每次&#x3D;&#x3D;请求Servlet时，Servlet容器都会调用Servlet的&#x3D;&#x3D;service()&#x3D;&#x3D;方法对请求进行处理</li><li>&#x3D;&#x3D;服务终止&#x3D;&#x3D;：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的&#x3D;&#x3D;destroy()&#x3D;&#x3D;方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ol></li><li><p>通过案例演示下上述的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Servlet生命周期方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化方法</span></span><br><span class="line"><span class="comment">     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     *  2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:如何才能让Servlet中的destroy方法被执行？&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220724181604957.png" alt="image-20220724181604957"></p></li></ul><p>在Terminal命令行中，先使用<code>mvn tomcat7:run</code>启动，然后再使用<code>ctrl+c</code>关闭tomcat</p><ul><li><strong>Servlet生命周期：1.加载和实例化。2.初始化。3.请求处理，调用service方法。4.服务终止。</strong></li></ul><p><strong>小结</strong></p><p>这节中需要掌握的内容是:</p><ol><li>Servlet对象在什么时候被创建的?</li></ol><blockquote><p>默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns &#x3D; “&#x2F;demo2”,loadOnStartup &#x3D; 1)的loadOnStartup 修改成在服务器启动的时候创建。</p></blockquote><ol start="2"><li>Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次?</li></ol><blockquote><p>涉及到三个方法，分别是 <strong>init()、service()、destroy()</strong></p><p>init方法在Servlet对象被创建的时候执行，只执行1次</p><p>service方法在Servlet被访问的时候调用，每访问1次就调用1次</p><p>destroy方法在Servlet对象被销毁的时候调用，只执行1次</p></blockquote><h1 id="6-方法介绍"><a href="#6-方法介绍" class="headerlink" title="6.方法介绍"></a>6.方法介绍</h1><p>Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？</p><p>我们先来回顾下前面讲的三个方法，分别是:</p><ul><li>初始化方法，在Servlet被创建时执行，只执行一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> </span><br></pre></td></tr></table></figure><ul><li>提供服务方法， 每次Servlet被访问，都会调用该方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br></pre></td></tr></table></figure><ul><li>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> </span><br></pre></td></tr></table></figure><p>剩下的两个方法是:</p><ul><li>获取Servlet信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getServletInfo</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取ServletConfig对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet方法介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化方法</span></span><br><span class="line"><span class="comment">     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     *  2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletConfig = config;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getServletInfo()和getServletConfig()这两个方法使用的不是很多，了解即可。</p><h1 id="7-体系结构"><a href="#7-体系结构" class="headerlink" title="7.体系结构"></a>7.体系结构</h1><p>通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢?</p><p>要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解:</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/1627240593506.png" alt="1627240593506"></p><p>因为我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承&#x3D;&#x3D;HttpServlet&#x3D;&#x3D;</p><p>具体的编写格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO GET 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO Post 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送<code>http://localhost:8080/web-demo/demo4</code>,就能看到doGet方法被执行了</li><li>要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个<code>a.html</code>页面，内容如下:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/web-demo/demo4&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动测试，即可看到doPost方法被执行了。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220724203049836.png" alt="image-20220724203049836"></p><h1 id="8-urlPattern配置"><a href="#8-urlPattern配置" class="headerlink" title="8.urlPattern配置"></a>8.urlPattern配置</h1><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径（&#x3D;&#x3D;urlPattern&#x3D;&#x3D;）</p><p>​    <img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220724203305629.png" alt="image-20220724203305629"></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220724205811274.png" alt="image-20220724205811274"></p><p>分为四个配置规则，精确匹配，目录匹配，扩展名匹配，任意匹配。基本上第一个用到的最多，精确匹配。</p><ul><li><strong>所有范围都是越小越优先。</strong></li></ul><p>唯一的扩展名匹配不用“&#x2F;”。记住上面图就好了。</p><h1 id="9-XML配置"><a href="#9-XML配置" class="headerlink" title="9.XML配置"></a>9.XML配置</h1><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p><p>对于XML的配置步骤有两步:</p><ul><li>编写Servlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo13</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo13 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在web.xml中配置该Servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 全类名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，名字任意--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet的类全名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.ServletDemo13<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 访问路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo13<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。</p>]]></content>
      
      
      <categories>
          
          <category> Java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC概述</title>
      <link href="/2021/04/07/java%20web/jdbc%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/07/java%20web/jdbc%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h1><p>在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。</p><h2 id="1-1-JDBC概念"><a href="#1-1-JDBC概念" class="headerlink" title="1.1 JDBC概念"></a>1.1 JDBC概念</h2><ul><li><p><strong>JDBC   就是使用Java语言操作关系型数据库的一套API</strong></p></li><li><p>全称：( Java DataBase Connectivity ) Java 数据库连接</p></li></ul><p>JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，<strong>而这套实现类（称之为：驱动）</strong>就由各自的数据库厂商给出。</p><h2 id="1-2-JDBC本质"><a href="#1-2-JDBC本质" class="headerlink" title="1.2 JDBC本质"></a>1.2 JDBC本质</h2><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即<strong>接口</strong></li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><p>—java只提供接口，让其他数据库去实现。</p><h2 id="1-3JDBC好处"><a href="#1-3JDBC好处" class="headerlink" title="1.3JDBC好处"></a>1.3JDBC好处</h2><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul><p>以后编写操作数据库的代码只需要面向<strong>JDBC</strong>（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。如下图就是MySQL驱动包**(jar包)**</p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20210725133015535.png" alt="image-20210725133015535" style="zoom:90%;" /><h1 id="2-JDBC快速入门"><a href="#2-JDBC快速入门" class="headerlink" title="2.JDBC快速入门"></a>2.JDBC快速入门</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718161202408.png" alt="image-20220718161202408"></p><h2 id="2-1编写代码步骤"><a href="#2-1编写代码步骤" class="headerlink" title="2.1编写代码步骤"></a>2.1编写代码步骤</h2><ul><li><p>创建工程，导入驱动jar包</p><img src="/Users/fanshiwei/Desktop/资料-javaweb全/day03-JDBC/ppt/assets/image-20210725133015535.png" alt="image-20210725133015535" style="zoom:90%;" /></li><li><p>注册驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</p></li><li><p>定义SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span>  “<span class="keyword">update</span>…” ;</span><br></pre></td></tr></table></figure></li><li><p>获取执行SQL对象</p><p>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeUpdate(<span class="keyword">sql</span>);  </span><br></pre></td></tr></table></figure></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ul><h2 id="2-2代码如下："><a href="#2-2代码如下：" class="headerlink" title="2.2代码如下："></a>2.2代码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC快速入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">        <span class="comment">//2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 2000 where id = 1&quot;</span>;</span><br><span class="line">        <span class="comment">//4. 获取执行sql的对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//受影响的行数</span></span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//7. 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-JDBC-API详解"><a href="#3-JDBC-API详解" class="headerlink" title="3.JDBC API详解"></a>3.JDBC API详解</h1><h2 id="3-1-DriverManager-工具类"><a href="#3-1-DriverManager-工具类" class="headerlink" title="3.1  DriverManager(工具类)"></a>3.1  DriverManager(工具类)</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718220023295.png" alt="image-20220718220023295"></p><p>DriverManager（驱动管理类）作用：</p><ul><li>3.1.1注册驱动</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><p>mysql8.0以上有改动 。</p><ul><li>3.1.2获取数据库连接</li></ul><p>参数说明：</p><ul><li><p>url ： 连接路径</p><blockquote><p>语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p><p>示例：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1</p><p>&#x3D;&#x3D;细节：&#x3D;&#x3D;</p><ul><li><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称?参数键值对</p></li><li><p>配置 useSSL&#x3D;false 参数，禁用安全连接方式，解决警告提示</p></li></ul></blockquote></li><li><p>user ：用户名</p></li><li><p>poassword ：密码</p></li></ul><h2 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2  Connection"></a>3.2  Connection</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718220045836.png" alt="image-20220718220045836"></p><p>Connection（数据库连接对象）作用：</p><ul><li>获取执行 SQL 的对象</li><li>管理事务</li></ul><p>3.2.1  获取执行对象</p><ul><li>普通执行SQL对象</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement createStatement()</span><br></pre></td></tr></table></figure><ul><li>预编译SQL的执行SQL对象：防止SQL注入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement  prepareStatement(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure><p>3.2.2  事务管理</p><p>先回顾一下MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><blockquote><p>MySQL默认是自动提交事务</p></blockquote><p>接下来学习JDBC事务管理的方法。</p><p>JDBC事务管理的方法：<strong>开启事务不太一样。</strong></p><ul><li><p>参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为为false。</p></li><li><p>可以在try catch异常里提交事务。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ============开启事务==========</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> stmt.executeUpdate(sql1);<span class="comment">//受影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count1);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> stmt.executeUpdate(sql2);<span class="comment">//受影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============提交事务==========</span></span><br><span class="line">    <span class="comment">//程序运行到此处，说明没有出现任何问题，则需求提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// ============回滚事务==========</span></span><br><span class="line">    <span class="comment">//程序在出现异常时会执行到这个地方，此时就需要回滚事务</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3  Statement"></a>3.3  Statement</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718220120556.png" alt="image-20220718220120556"></p><p>Statement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。</p><h2 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4  ResultSet"></a>3.4  ResultSet</h2><p>ResultSet（结果集对象）作用：</p><ul><li>&#x3D;&#x3D;封装了SQL查询语句的结果。&#x3D;&#x3D;</li></ul><p>而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet  executeQuery(<span class="keyword">sql</span>)：执行DQL 语句，返回 ResultSet 对象</span><br></pre></td></tr></table></figure><p>那么我们就需要从 <code>ResultSet</code> 对象中获取我们想要的数据。<code>ResultSet</code> 对象提供了操作查询结果数据的方法，如下：</p><blockquote><p>boolean  next()</p><ul><li>将光标从当前位置向前移动一行 </li><li>判断当前行是否为有效行</li></ul><p>方法返回值说明：</p><ul><li>true  ： 有效航，当前行有数据</li><li>false ： 无效行，当前行没有数据</li></ul></blockquote><blockquote><p>xxx  getXxx(参数)：获取数据</p><ul><li>xxx : 数据类型；如： int getInt(参数) ；String getString(参数)</li><li>参数<ul><li>int类型的参数：列的编号，从1开始</li><li>String类型的参数： 列的名称</li></ul></li></ul></blockquote><p>如下图为执行SQL语句后的结果</p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20210725181320813.png" alt="image-20210725181320813" style="zoom:80%;" /><p>一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p><h2 id="3-5-PreparedStatement"><a href="#3-5-PreparedStatement" class="headerlink" title="3.5  PreparedStatement"></a>3.5  PreparedStatement</h2><p>继承之Statement</p><p><strong>预编译SQL语句并执行：预防SQL注入问题</strong></p><h3 id="3-5-1-SQL注入"><a href="#3-5-1-SQL注入" class="headerlink" title="3.5.1 SQL注入"></a>3.5.1 SQL注入</h3><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718222858491-20220718223230878.png" alt="image-20220718222858491"></p><p>这种往往常会有漏洞</p><p>那么该如何解决呢？这里就可以将SQL执行对象 <code>Statement</code> 换成 <code>PreparedStatement</code> 对象。</p><h3 id="3-5-2-代码模拟SQL注入问题"><a href="#3-5-2-代码模拟SQL注入问题" class="headerlink" title="3.5.2 代码模拟SQL注入问题"></a>3.5.2 代码模拟SQL注入问题</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入 用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;sjdljfld&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span>+name+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+pwd+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取stmt对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">// 判断登录是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;sjdljfld&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span><span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面语句可以看出条件 <code>username = &#39;sjdljfld&#39; and password = &#39;&#39;</code> 不管是否满足，而 <code>or</code> 后面的 <code>&#39;1&#39; = &#39;1&#39;</code> 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。</p><h3 id="3-5-3-PreparedStatement概述"><a href="#3-5-3-PreparedStatement概述" class="headerlink" title="3.5.3 PreparedStatement概述"></a>3.5.3 PreparedStatement概述</h3><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><ul><li><p>获取 PreparedStatement 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL语句中的参数值，使用？占位符替代</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 通过Connection对象获取，并传入对应的sql语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><p>上面的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值。</p><blockquote><p>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值</p><ul><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p><ul><li><p>参数1： ？的位置编号，从1 开始</p></li><li><p>参数2： ？的值</p></li></ul></li></ul></blockquote></li><li><p>执行SQL语句</p><blockquote><p>executeUpdate();  执行DDL语句和DML语句</p><p>executeQuery();  执行DQL语句</p><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><ul><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</li></ul></blockquote></li></ul><h1 id="4-数据库连接池"><a href="#4-数据库连接池" class="headerlink" title="4. 数据库连接池"></a>4. 数据库连接池</h1><h2 id="4-1-数据库连接池简介"><a href="#4-1-数据库连接池简介" class="headerlink" title="4.1  数据库连接池简介"></a>4.1  数据库连接池简介</h2><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220718221432323.png" alt="image-20220718221432323"></p><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h2 id="4-2-数据库连接池实现"><a href="#4-2-数据库连接池实现" class="headerlink" title="4.2  数据库连接池实现"></a>4.2  数据库连接池实现</h2><ul><li><p>标准接口：&#x3D;&#x3D;DataSource&#x3D;&#x3D;</p><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection <span class="title function_">getConnection</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p></li><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h2 id="4-3-Driud使用"><a href="#4-3-Driud使用" class="headerlink" title="4.3  Driud使用"></a>4.3  Driud使用</h2><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul><p>编写配置文件如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">1234</span></span><br><span class="line"><span class="comment"># 初始化连接数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大等待时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>使用druid的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid数据库连接池演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.定义配置文件</span></span><br><span class="line">        <span class="comment">//3. 加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection); <span class="comment">//获取到了连接后就可以继续做其他操作了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java web基本概念</title>
      <link href="/2021/03/07/java%20web/Java%20web%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/03/07/java%20web/Java%20web%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java-web"><a href="#1-Java-web" class="headerlink" title="1.Java web"></a>1.Java web</h1><h2 id="1-1Java-web基本概念："><a href="#1-1Java-web基本概念：" class="headerlink" title="1.1Java web基本概念："></a>1.1Java web基本概念：</h2><ul><li><p>静态web：html，css</p><ul><li>（提供给所有人看的数据，始终不会发生变化）</li></ul></li><li><p>动态web：Servlet&#x2F;JSP，ASP，PHP，</p></li><li><ul><li>淘宝等几乎所有的网站（提供给所有人看的数据，始终会发生变化，每个人在不同时间，不同地方看到的都不同）</li></ul></li></ul><h2 id="1-2web应用程序"><a href="#1-2web应用程序" class="headerlink" title="1.2web应用程序"></a>1.2web应用程序</h2><p>web应用程序：可以提供浏览器访问的程序</p><ul><li>a.html、b.html等多个web资源，这些web资源可以被外界访问，对外界提供服务。</li></ul><ul><li>能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</li><li>URL：统一资源定位符。</li><li>这个统一的web资源会被放在同一个文件夹下，web应用程序—&gt;Tomcat：服务器。</li><li>一个web应用由多部分组成（静态web、动态web）<ul><li>html、css、js、</li><li>jsp、servlet</li><li>java程序</li><li>jar包</li><li>配置文件（properties）</li></ul></li></ul><ul><li>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理。</li></ul><h2 id="1-3静态web"><a href="#1-3静态web" class="headerlink" title="1.3静态web"></a>1.3静态web</h2><p><em>.htm，</em>.html，这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711161131442.png" alt="image-20220711161131442"></p><p>静态web存在的缺点</p><ul><li><p>Web页面无法动态更新，所用用户看到的都是同一个页面</p></li><li><p>轮播图，伪动态</p></li><li><p>javaScript（实际开发中，用的最多）</p></li><li><p>它无法和数据库交互（数据无法持久化，用户无法交互）</p></li></ul><h2 id="1-4动态web"><a href="#1-4动态web" class="headerlink" title="1.4动态web"></a>1.4动态web</h2><p>页面会动态展示：Web的页面展示的效果因人而异。（千人千面）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711161620630.png" alt="image-20220711161620630"></p><p>动态web存在的缺点</p><ul><li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布。</li><li><ul><li>停机维护</li></ul></li></ul><p>优点：</p><ul><li>web页面可以动态更新，所有用户看到都不是同一个页面</li><li>它可以与数据库交互（数据持久化：注册，商品信息。）</li></ul><h2 id="1-5web服务器"><a href="#1-5web服务器" class="headerlink" title="1.5web服务器"></a>1.5web服务器</h2><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息。</p><p>Java编写的[服务器端程序：JSP&#x2F;Servlet：</p><p>架构：B&#x2F;S：浏览和服务器</p><p>C&#x2F;S：客户端和服务器</p><ul><li>sun公司主推的B&#x2F;S架构</li><li>基于Java语言的，大部分开源组件</li><li>可以承载三高问题带来的影响（高并发、高可用、高性能）</li></ul><p>服务器：</p><p>IIS：Windows中自带</p><p>tomacat：Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。</p><h1 id="2-tomacat详解"><a href="#2-tomacat详解" class="headerlink" title="2.tomacat详解"></a>2.tomacat详解</h1><p>文件夹作用：</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711163936350.png" alt="image-20220711163936350"></p><p>temp：临时变量</p><p>work：工作目录</p><h2 id="2-1配置"><a href="#2-1配置" class="headerlink" title="2.1配置"></a>2.1配置</h2><p>可以配置启动的端口号</p><ul><li>tomacat的默认端口号：8080</li><li>mysql：3306</li><li>http：80</li><li>https：443</li></ul><p>在tomacat文件里，server.xml文件。</p><pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;</code></pre><p>可以配置主机的名称</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711170337522.png" alt="image-20220711170337522"></p><p>可以改但没必要</p><h2 id="2-2面试题：请你谈谈网站是如何访问的？"><a href="#2-2面试题：请你谈谈网站是如何访问的？" class="headerlink" title="2.2面试题：请你谈谈网站是如何访问的？"></a>2.2面试题：请你谈谈网站是如何访问的？</h2><ol><li><p>输入一个域名，回车</p></li><li><p>检查本机的C:Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射<br>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问。</p><p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711170814457.png" alt="image-20220711170814457"></p><h1 id="3-Http"><a href="#3-Http" class="headerlink" title="3.Http"></a>3.Http</h1><h2 id="3-1什么是Http"><a href="#3-1什么是Http" class="headerlink" title="3.1什么是Http"></a>3.1什么是Http</h2><p>HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p><ul><li>TCP：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li></ul><ul><li>文本：html，字符串…</li><li>超文本：图片，音乐，视频，定位，地图…</li><li>默认端口：80<br>HTTPS：安全的协议</li><li>默认端口：443</li></ul><h2 id="3-2http的两个时代"><a href="#3-2http的两个时代" class="headerlink" title="3.2http的两个时代"></a>3.2http的两个时代</h2><ul><li>http1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接。</li><li>http2.0：客户端可以与web服务器连接后，可以获得多个web资源。</li></ul><h2 id="3-3http请求"><a href="#3-3http请求" class="headerlink" title="3.3http请求"></a>3.3http请求</h2><p>客户端—-&gt;发请求(request)—-&gt;服务器（比如：访问百度）</p><p>百度F12查看（拿百度举例，其他网站也可以）</p><p>General</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Request URL: https://www.baidu.com/`          // 请求地址</span><br><span class="line">2. Request Method: GET                   // 请求方法：get方法/post方法</span><br><span class="line">3. `Status Code: 200 OK`                      // 状态代码：200，也有3或者4和5开头</span><br><span class="line">4. `Remote（远程） Address: 14.215.177.38:443             // 远程地址</span><br><span class="line">5. `Referrer Policy: strict-origin-when-cross-origin   // 引用站点策略</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220711172025351.png" alt="image-20220711172025351"></p><h3 id="3-3-1请求行"><a href="#3-3-1请求行" class="headerlink" title="3.3.1请求行"></a>3.3.1请求行</h3><ul><li>请求行中的请求方式：GET</li><li>请求方式：Get，Post，HEAD，DELETE，PUT…<br><strong>GET:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效。</strong><br><strong>POST:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</strong></li><li>一般用到get和post比较多</li></ul><h3 id="3-3-2请求头（消息头）"><a href="#3-3-2请求头（消息头）" class="headerlink" title="3.3.2请求头（消息头）"></a>3.3.2请求头（消息头）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept: 告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding: 告诉浏览器，它支持哪种编码格式：GBK,UTF-8,GB2312,ISO8859-1</span><br><span class="line">Accept-Language: 告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control: 缓存控制</span><br><span class="line">Connection: 告诉浏览器，请求完成是断开还是保持</span><br><span class="line">HOST：主机</span><br></pre></td></tr></table></figure><h2 id="3-4http响应"><a href="#3-4http响应" class="headerlink" title="3.4http响应"></a>3.4http响应</h2><p>同是百度里找到：</p><p>&#x2F;&#x2F; 缓存控制<br>Cache-Control: no-cache<br>&#x2F;&#x2F; 保持连接（http1.1）<br>Connection: keep-alive<br>&#x2F;&#x2F; 文本编码类型<br>Content-Encoding: gzip<br>&#x2F;&#x2F; 响应类型<br>Content-Type: text&#x2F;html;charset&#x3D;utf-8</p><h3 id="3-4-1响应体"><a href="#3-4-1响应体" class="headerlink" title="3.4.1响应体"></a>3.4.1响应体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Accept: 告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding: 告诉浏览器，它支持哪种编码格式：GBK,UTF-8,GB2312,ISO8859-1</span><br><span class="line">Accept-Language: 告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control: 缓存控制</span><br><span class="line">Connection: 告诉浏览器，请求完成是断开还是保持</span><br><span class="line">HOST：主机</span><br><span class="line">Refrush：告诉客户端，多久刷新一次</span><br><span class="line">Location：让网页重新定位</span><br></pre></td></tr></table></figure><h3 id="3-4-2响应状态码（重点）"><a href="#3-4-2响应状态码（重点）" class="headerlink" title="3.4.2响应状态码（重点）"></a>3.4.2响应状态码（重点）</h3><ul><li><p>200：响应成功</p></li><li><p>3xx：请求重定向（304等等）</p><p>—–&gt;&gt;&gt;重定向：你重新给我到你新位置去。</p></li><li><p>4xx：找不到资源（404等等）</p><p>—–&gt;&gt;&gt;资源不存在 </p></li><li><p>5xx：服务器代码错误（500代码错误，502网关错误）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 注解和反射</title>
      <link href="/2020/08/02/java/day16-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/08/02/java/day16-%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是注解（Annotation）"><a href="#1-什么是注解（Annotation）" class="headerlink" title="1.什么是注解（Annotation）"></a>1.什么是注解（Annotation）</h1><p>1.Annotation 是从JDK 5.0开始引入的新技术</p><p>2.Annotation的作用：</p><p>​不是程序本身，<strong>可以对程序作出解释</strong>（这一点和注释（comment）没什么区别）<strong>可以被其他程序</strong>（比如：编译器等）<strong>读取</strong>。</p><p>3.Annotation 的格式<br>    注解是以“@注释名”在代码中存储在的，还可以添加一些参数值，例如果：@SuppressWarnings（value&#x3D;“unchecked”）.</p><p>4.Annotation 在哪里使用？</p><p>​可以附加在<strong>package 、class、method、field</strong> 等上面，相当于给他们添加了额外的辅助信息，我们可以通过<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%B0%84&spm=1001.2101.3001.7020">反射</a>机制实现对这些元数据的访问。</p><p>​注解和注释还是有很多相似的，比如他们都有个“注”，注释是给人看的，注解也是给人看的，但是它多了个“解”字。这个“解”是给程序来解释，这是一个区别 。</p><h1 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801141954680.png" alt="image-20220801141954680"></p><p>1.@Override：定义在java.lang.Override 中，此注解只使用于修辞方法，表示一个方法声明打算<strong>重写超类中的另一个方法声明。</strong></p><ul><li>重写的注解</li></ul><p>2.@Deprecated：定义在java.lang.Deprecated中，此注解，可以用于修辞方法、属性、类、表示不鼓励程序员使用这样的元素，同时是因为它很危险或者存在更好的选择。（一般来说表示<strong>废弃了的方法、或者类</strong>等等）</p><ul><li>不推荐程序员使用，但是可以使用，或者存在更好的方式。</li></ul><p>3.@SuppressWarnings：<br>  定义在java.lang.SuppressWarings 中，用来抑制编译时的警告信息，<br>与前两个注解有所不同，需要添加一个参数才能正确使用，这些参数都是已经定义好了的<br>@SuppressWarnings（“all”）<br>@SuppressWarnings（“unchecked”）<br>@SuppressWarnings（value&#x3D;{“unchecked”，“deprecation”}）<br>等等**(用于镇压警告)**</p><h1 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3.元注解"></a>3.元注解</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801142733948.png" alt="image-20220801142733948"></p><p>元注解的作用就是<strong>负责注解其他注解</strong>，Java定义了四个标准的meta-annotation类型，它们被<strong>用来提供对其他annotation 类型做说明</strong>。这些类型和它们锁支持的类在java.langannotation 包中可以找到（@Target，@Retention，@Documented，@Inherited）</p><p>1.<strong>@Target</strong>：用于描述<strong>注解的使用范围</strong>（即：被描述的注解可以用在什么地方）(常用)</p><p>2.<strong>@Retention</strong>：表示需要在什么级别保存该注解信息，用于<strong>描述注解的生命周期</strong>（SOURCE（源代码） 《 CLASS（字节码） 《 RUNTIEM（运行时））(常用)</p><p>3.<strong>@Document</strong>：说明该注解将被<strong>包含在javadoc中</strong></p><p>4.<strong>@Inherited</strong>：说明<strong>子类可以继承父类中的该注解</strong></p><h1 id="4-自定义注解"><a href="#4-自定义注解" class="headerlink" title="4.自定义注解"></a>4.自定义注解</h1><ul><li><p>使用@interface 自定义注解是，自动继承了 java.lang.annotation.Annotation接口</p></li><li><p><strong>分析：</strong><br>  1.@Interited 用来声明一个注解，格式：public @ interface 注解名{ 定义内容 }<br>  2.其中的每一个方法实际上是声明了一个配置参数<br>  3.<strong>方法的名称就是参数的名称</strong><br>  4.<strong>返回值类型就是参数的类型</strong>（返回值只能是基本类型，Class，String，enum）。<br>  5.<strong>可以通过default 来声明参数的默认值</strong><br>  6.如果只有一个参数成员，一般参数名为value<br>  7.注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</p></li></ul><p><strong>案例1：自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//注解可以显示赋值，如果没有默认值，我们就必须给注解赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;Fan&quot;,schools = &#123;&quot;加里敦大学&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Target和Retention有点类似固定搭配，后面加TYPE、METHOD、RUNTIME自动输出语句</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解的参数：参数类型 + 参数名（）；</span></span><br><span class="line">    <span class="comment">// 注意：这并不是一个方法</span></span><br><span class="line">    <span class="comment">//default &quot;&quot;:默认值，默认为空</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//如果默认值为-1，代表不存在</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一些数组，如果没加，默认这个大学</span></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">&quot;曼城&quot;</span>,<span class="string">&quot;曼彻斯特大学&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：只有一个值</strong><br>如果注解只有一个值，可以使用value命名，可以在调用的使用省略value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注解只有一个值，可以使用value命名，可以在调用的使用省略value</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//如果只有一个参数建议以value 命名</span></span><br><span class="line">    <span class="comment">//如果注解只有一个值，可以使用value命名，可以在调用的使用省略value</span></span><br><span class="line">    <span class="comment">//case1：如果是String name()，那么就要 name = &quot;fan&quot;</span></span><br><span class="line">    <span class="comment">//       如果是String value()，那么可以省略value 直接写&quot;fan&quot;</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果只有一个值，但其名称不是value，则不能省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation2(&quot;哈兰德&quot;)</span><span class="comment">//这个哈兰德就会报错。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果注解只有一个值，可以使用value命名，可以在调用的使用省略value</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//如果只有一个参数建议以value 命名</span></span><br><span class="line">    <span class="comment">//如果注解只有一个值，可以使用value命名，可以在调用的使用省略value</span></span><br><span class="line">    <span class="comment">//case1：如果是String name()，那么就要 name = &quot;fan&quot;</span></span><br><span class="line">    <span class="comment">//       如果是String value()，那么可以省略value 直接写&quot;fan&quot;</span></span><br><span class="line">    <span class="comment">//String value();</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-Java反射概述"><a href="#5-Java反射概述" class="headerlink" title="5.Java反射概述"></a>5.Java反射概述</h1><h2 id="5-1动态-VS-静态语言"><a href="#5-1动态-VS-静态语言" class="headerlink" title="5.1动态 VS 静态语言"></a>5.1<strong>动态 VS 静态语言</strong></h2><p><strong>动态语言：</strong><br>    是一类在<strong>运行时可以改变其结构的语言</strong>:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p><p>​主要动态语言:Object-C、C#、JavaScript、PHP、Python等。</p><p><strong>静态语言：</strong><br>    与动态语言相对应的，<strong>运行时结构不可变的语言</strong>就是静态语言。如Java、C、C++。</p><p>​<strong>Java不是动态语言</strong>，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以<strong>利用反射机制获得类似动态语言的特性</strong>。Java的动态性让编程的时候更加灵活!</p><h2 id="5-2Java-Reflection"><a href="#5-2Java-Reflection" class="headerlink" title="5.2Java Reflection"></a>5.2<strong>Java Reflection</strong></h2><p>  <strong>Reflection(反射）是Java被视为动态语言的关键，</strong>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<strong>（写出来的代码编译成.class之后就不能变了）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)</span><br></pre></td></tr></table></figure><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有<br>一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为:反射（倒退）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801154604310.png" alt="image-20220801154604310"></p><h2 id="5-3Java-反射机制提供的功能"><a href="#5-3Java-反射机制提供的功能" class="headerlink" title="5.3Java 反射机制提供的功能"></a>5.3<strong>Java 反射机制提供的功能</strong></h2><p>​1.在运行时<strong>判断</strong>任意一个<strong>对象所属的类</strong><br>​2.在运行时<strong>构造</strong>任意一个<strong>类的对象</strong><br>​3.在运行时<strong>判断</strong>任意一个<strong>类所具有的成员变量和方法</strong><br>​4.在运行时<strong>获取泛型信息</strong><br>​5.在运行时<strong>调用</strong>任意一个<strong>对象的成员变量和方法</strong><br>​6.在运行时<strong>处理注解</strong><br>​7.生成<strong>动态代理</strong>（AOP常用）</p><p><strong>反射优缺点</strong>：</p><ul><li><p>优点:可以实现动态创建对象和编译，体现出很大的灵活性</p></li><li><p>缺点:对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</p></li></ul><h2 id="5-4反射相关主要API"><a href="#5-4反射相关主要API" class="headerlink" title="5.4反射相关主要API"></a>5.4<strong>反射相关主要API</strong></h2><p>  java.lang.<strong>Class</strong> :代表一个类</p><p>  java.lang.reflect.<strong>Method</strong>:代表类的方法</p><p>  java.lang.reflect.<strong>Field</strong>:代表类的成员变量</p><p>  java.lang.reflect.<strong>Constructor</strong>:代表类的构造器</p><p>案例1:通过反射获取类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//什么叫反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//通过反射获取类的Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实体类:pojo ||(或者) entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">//实体类内容就不写了，太长了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译输出</span></span><br><span class="line">编译器：<span class="keyword">class</span> <span class="title class_">User</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个类在内存中只有一个class对象</span></span><br><span class="line"><span class="comment">//一个类被加载后，类的整个结构都会被封装在Class对象中。</span></span><br></pre></td></tr></table></figure><h1 id="6-Class-类"><a href="#6-Class-类" class="headerlink" title="6.Class 类"></a>6.Class 类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>​以上的方法返回值的类型是一个Class类，此类是Java反射的<strong>源头</strong>，实际上所谓反射从程序的运行结果来看也很好理解，即:可以<strong>通过对象反射求出类的名称。</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801163136983.png" alt="image-20220801163136983"></p><p>​对象照镜子后可以得到的信息:某个类的<strong>属性、方法和构造器、某个类到底实现了哪些接口</strong>。对于每个类而言，JRE都为其<strong>保留一个不变的Class类型的对象</strong>。一个Class对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;门)的有关信息。</p><p>  1.Class本身也是一个类<br>  2.Class对象<strong>只能由系统建立对象</strong><br>  3.一个加载的类在JVM中<strong>只会有一个Class实例</strong><br>  4.一个Class对象对应的是一个加载到JVM中的一个.class文件<br>  5.每个类的实例都会记得自己是由哪个Class 实例所生成<br>  6.通过Class可以完整地得到一个类中的所有被加载的结构<br>  7.Class类是Reflection的根源，针对任何你想动态加载、运行的类，<strong>唯有先获得相应的Class对象</strong></p><h2 id="6-1Class-类的常用方法"><a href="#6-1Class-类的常用方法" class="headerlink" title="6.1Class 类的常用方法"></a>6.1<strong>Class 类的常用方法</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801163547465.png" alt="image-20220801163547465"></p><h2 id="6-2获取Class类的实例（面试题：获取对象有哪几种方式？）"><a href="#6-2获取Class类的实例（面试题：获取对象有哪几种方式？）" class="headerlink" title="6.2获取Class类的实例（面试题：获取对象有哪几种方式？）"></a>6.2<strong>获取Class类的实例</strong>（面试题：获取对象有哪几种方式？）</h2><p>1.若<strong>已知具体的类</strong>，通过类的<strong>class属性获取</strong>，该方法最为安全可靠，程序性能最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz= Person.class;</span><br></pre></td></tr></table></figure><p>2.<strong>已知某个类的实例</strong>，调用该实例的**getClass()**方法获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure><p>3.<strong>已知一个类的全类名</strong>，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException**(最常用)**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz= Class.forName(<span class="string">&quot;demo01.Student&quot;</span>);</span><br></pre></td></tr></table></figure><p>4.内置基本数据类型可以直接用类名.Type</p><p>5.还可以利用ClassLoader。</p><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;这个人是：&quot;</span>+person.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：通过对象获得</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2. forname 获取</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式3. 通过类名.class 获得</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式4：基本内置类型的包装类都有一个Type 属性</span></span><br><span class="line">        Class&lt;Integer&gt; c4 = Integer.TYPE;</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">///获得父类类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> c1.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-哪些类型可以有Class-对象？"><a href="#7-哪些类型可以有Class-对象？" class="headerlink" title="7.哪些类型可以有Class 对象？"></a>7.哪些类型可以有Class 对象？</h2><p>    <strong>1.class:外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</strong><br>  <strong>2.interface:接口</strong><br>  <strong>3.[ ] ：数组</strong><br>  <strong>4.enum:枚举</strong><br>  <strong>5.annotation:注解 @interface</strong><br>  <strong>6.primitive type ：基本数据类型</strong><br>  <strong>7.void</strong></p><h2 id="8-类加载与内存分析"><a href="#8-类加载与内存分析" class="headerlink" title="8.类加载与内存分析"></a>8.类加载与内存分析</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801205440841.png" alt="image-20220801205440841"></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801213620639.png" alt="image-20220801213620639"></p><p><strong>方法区是一个特殊的堆</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801205625680.png" alt="image-20220801205625680"></p><p><strong>加载:</strong><br>  <strong>将class文件字节码内容加载到内存中</strong>，并将这些静态数据转换成方法区的运行时数据结构,**然后生成一个代表这个类的java.lang.Class对象.**（获取，不能主动创建）</p><p><strong>链接:</strong><br>  将Java类的二进制代码合并到JVM的运行状态之中的过程。<br>  1.验证: 确保加载的类信息符合JVM规范，没有安全方面的问题<br>  2.准备: 正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。<br>  3.解析: 虚拟机常量池内的符号引用（常量名）替换为直接引用(地址)的过程。</p><p><strong>初始化:</strong><br>  1.执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器)。<br>  2.当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。<br>  3.虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。</p><h2 id="9-什么时候会发生类的初始化"><a href="#9-什么时候会发生类的初始化" class="headerlink" title="9.什么时候会发生类的初始化"></a>9.什么时候会发生类的初始化</h2><h2 id="9-1类的主动引用-一定会发生类的初始化"><a href="#9-1类的主动引用-一定会发生类的初始化" class="headerlink" title="9.1类的主动引用(一定会发生类的初始化)"></a>9.1类的<strong>主动</strong>引用(一定会发生类的初始化)</h2><p>  1.当虚拟机启动，先初始化main方法所在的类<br>  2.new一个类的对象<br>  3.调用类的静态成员(除了final常量)和静态方法<br>  4.使用java.lang.reflect包的方法对类进行反射调用<br>  5.当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p><h2 id="9-2类的被动引用-不会发生类的初始化"><a href="#9-2类的被动引用-不会发生类的初始化" class="headerlink" title="9.2类的被动引用(不会发生类的初始化)"></a>9.2类的被动引用(不会发生类的初始化)</h2><p>  1.当访问一个静态域时，只有真正声明这个域的类才会被初始化。如:当通过子类引用父类的静态变量，不会导致子类初始化<br>  2.通过数组定义类引用，不会触发此类的初始化<br>  3.引用常量不会触发此类的初始化（<strong>常量在链接阶段就存入调用类的常量池中了</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.反射也会产生主动引用</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;cn.Son&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不会产生类的引用方法</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Son.M);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-类加载器的作用"><a href="#10-类加载器的作用" class="headerlink" title="10.类加载器的作用"></a>10.类加载器的作用</h1><p><strong>类加载的作用</strong>:<br>  将<strong>class文件字节码内容加载到内存中</strong>，并将这些静态数据转换成方法区的运行时数据结构，然后在<strong>堆中生成一个代表这个类的java.lang.Class</strong>对象，作为方法区中类数据的访问入口。</p><p><strong>类缓存</strong>:<br>  标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将<strong>维持加载（缓存）一段时间。</strong>不过JVM垃圾回收机制可以回收这些Class对象</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801214524231.png" alt="image-20220801214524231"></p><p>类加载器作用是用来把类（class）装载进内存的。JVM 规范定义了如下类型的类加载器。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801214620102.png" alt="image-20220801214620102"></p><p><strong>引导类加载器</strong>:<br>  用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取。</p><p><strong>扩展类加载器</strong>:<br>  负责jre&#x2F;lib&#x2F;ext目录下的jar包或-java.ext.dirs指定目录下的jar包装入工作库。</p><p><strong>系统类加载器</strong>:<br>  负责java -classpath或-Djava.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//获取系统的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器的父类加载器-&gt;扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器-&gt;根加载器（C++）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">        System.out.println(parent1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试当前类是哪个加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Test04&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(c1);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试JDK内部哪个加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(c2);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-1创建运行时类的对象"><a href="#10-1创建运行时类的对象" class="headerlink" title="10.1创建运行时类的对象"></a>10.1<strong>创建运行时类的对象</strong></h2><p>通过反射获取运行时类的完整结构<br>  Field、Method、Constructor、Superclass、Interface、Annotation</p><p>  1.实现的全部接口<br>  2.所继承的父类<br>  3.全部的构造器<br>  4.全部的方法<br>  5.全部的Field<br>  6.注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的名称</span></span><br><span class="line">        System.out.println(c1.getName());<span class="comment">//获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName());<span class="comment">//类名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        Field[] fields = c1.getFields();<span class="comment">//只能找到public 修饰的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123; </span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        fields = c1.getDeclaredFields();<span class="comment">//找到private 修饰的属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定属性的值</span></span><br><span class="line">        <span class="comment">//Field name = c1.getField(&quot;name&quot;);报错</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        Method[] methods = c1.getMethods();<span class="comment">//获取本类及父类的全部public 方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getMethods（）：&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        methods = c1.getDeclaredMethods();<span class="comment">//获取本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getDeclaredMethods（）：&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        System.out.println(getName);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = c1.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getConstructors&quot;</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        constructors = c1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getDeclaredConstructors（）：&quot;</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定构造器</span></span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定&quot;</span>+declaredConstructor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801220221083.png" alt="image-20220801220221083"></p><h2 id="10-2如何获取属性，方法，构造器名称"><a href="#10-2如何获取属性，方法，构造器名称" class="headerlink" title="10.2如何获取属性，方法，构造器名称"></a>10.2如何获取属性，方法，构造器名称</h2><p><strong>有了Class对象，能做什么呢？</strong><br>  1.创建类的对象:调用Class对象的<strong>newlnstance()<strong>方法<br>  2.类</strong>必须有一个无参数的构造器。</strong><br>  3.类的构造器的访问权限需要足够</p><p>思考?难道**没有无参的构造器就不能创建对象了吗?**只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</p><p><strong>步骤如下</strong>:<br>  1.通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>  2.向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数<br>  3.通过Constructor实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">        <span class="comment">//构造一个对象</span></span><br><span class="line">        <span class="comment">//User user = (User)c1.newInstance();//本质上是调用了类的无参构造器</span></span><br><span class="line">        <span class="comment">// System.out.println(user);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt; constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//User user2 = (User)constructor.newInstance(&quot;kobe&quot;, 1, 18);</span></span><br><span class="line">        <span class="comment">//System.out.println(user2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)c1.newInstance();</span><br><span class="line">        <span class="comment">//通过反射获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//invoke ： 激活的意思</span></span><br><span class="line">        setName.invoke(user,<span class="string">&quot;范&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射操作属性</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">c4</span> <span class="operator">=</span> (User)c1.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//关掉检查</span></span><br><span class="line">        <span class="comment">//反射不同直接操作私有属性，需要关闭安全简则，属性或方法的setAccessible</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(c4,<span class="string">&quot;反射设置属性&quot;</span>);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-调用指定方法"><a href="#11-调用指定方法" class="headerlink" title="11.调用指定方法"></a>11.调用指定方法</h1><p>通过反射，调用类中的方法，通过<strong>Method</strong>类完成。<br>  ①通过Class类的<strong>getMethod</strong>(String name,Class…parameterTypes)方法取得一个Method对象， 并设置此方法操作时所需要的参数类型。</p><p>  ②之后使用Object <strong>invoke</strong>(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220801221657815.png" alt="image-20220801221657815"></p><p><strong>Object invoke(Object obj,Object … args)</strong></p><p>  1.Objectb对应原方法的返回值，若原方法无返回值，此时返回null<br>  2.若原方法若为静态方法，此时形参Object obj可为null<br>  3.若原方法形参列表为空，则Object[] args为null<br>  4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的**setAccessible(true)**方法，将可访问private的方法。</p><p><strong>setAccessible(true)</strong><br>  1.<strong>Method</strong>和Field、Constructor对象都有setAccessible()方法<br>  2.setAccessible作用是<strong>启动和禁用</strong>访问安全检查的开关。<br>  3.参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<br>    提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。<br>    使得原本无法访问的私有成员也可以访问<br>  4.参数值为false则指示反射的对象应该实施Java语言访问检查</p><p>练习：性能对比分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方式调用10亿次：&quot;</span> + (end - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) c1.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方式调用10亿次：&quot;</span> + (end - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用，关闭进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) c1.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭检测方式调用10亿次：&quot;</span> + (end - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-反射操作泛型"><a href="#12-反射操作泛型" class="headerlink" title="12.反射操作泛型"></a>12.反射操作泛型</h2><p>  Java采用泛型擦除的机制来引入泛型,<strong>Java中的泛型仅仅是给编译器javac使用的</strong>,确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成﹐所有和泛型有关的类型型全部擦除</p><p>  为了通过反射操作这些类型,Java新增了ParameterizedType , GenericArrayType ,TypeVariable和 Wildcardlype 几种类型来代表不能被归一到Class 类中的类型，但是又和原始数据类型齐名的类型。<br>  1.<strong>ParameterizedType</strong>： 表示一种参数化类型，比如Collection<br>  2.<strong>GenericArrayType</strong>: 表示一种元素类型是参数化类型或者类型变量的数组类型<br>  3.<strong>TypeVariable</strong>: 是各种类型变量的公共父接口<br>  4.<strong>WildcardType</strong>: 代表一种通配符类型表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">(Map&lt;String, User&gt; map, List&lt;User&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, User&gt; <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;Test09&gt; c1 = Test09.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">test01</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;test01&quot;</span>, Map.class, List.class);</span><br><span class="line">        <span class="comment">//获取参数的泛型参数类型</span></span><br><span class="line">        Type[] genericParameterTypes = test01.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(genericParameterType);</span><br><span class="line">            <span class="comment">//判断这个泛型是不是参数化类型</span></span><br><span class="line">            <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================================&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span>  ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印</span></span><br><span class="line">java.util.Map&lt;java.lang.String, User&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">java.util.List&lt;User&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">===================================================================</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br></pre></td></tr></table></figure><h2 id="13-获取注解信息"><a href="#13-获取注解信息" class="headerlink" title="13.获取注解信息"></a>13.获取注解信息</h2><p>  <strong>getAnnotation</strong><br>  <strong>getAnnotations</strong></p><p>练习：ORM<br>了解什么是ORM？<br>Object relationship Mapping –》对象关系映射</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220802091733642.png" alt="image-20220802091733642"></p><p>1.类和表结构对应<br>2.属性和字段对应<br>3.对象和记录对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableXy(&quot;db_student&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@FieldXy(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 18)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@FieldXy(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@FieldXy(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 3)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类名的注解</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableXy&#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target(value = &#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FieldXy&#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">编译器：</span><br><span class="line"><span class="meta">@cn</span>.bloghut.annotation.TableXy(value=db_student)</span><br><span class="line">db_student</span><br><span class="line">columnName：db_name   type：varchar   length：<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 的内部类</title>
      <link href="/2020/07/30/java/day15-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2020/07/30/java/day15-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-内部类概述"><a href="#1-内部类概述" class="headerlink" title="1.  内部类概述"></a>1.  内部类概述</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730212844974.png" alt="image-20220730212844974"></p><h3 id="1-1-1-什么是内部类"><a href="#1-1-1-什么是内部类" class="headerlink" title="1.1.1 什么是内部类"></a>1.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><h3 id="1-1-2-什么时候使用内部类"><a href="#1-1-2-什么时候使用内部类" class="headerlink" title="1.1.2 什么时候使用内部类"></a>1.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730213013808.png" alt="image-20220730213013808"></p><ol><li>为了实现更好的封装性。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730212918892.png" alt="image-20220730212918892"></p><h2 id="1-2-内部类的分类"><a href="#1-2-内部类的分类" class="headerlink" title="1.2 内部类的分类"></a>1.2 内部类的分类</h2><p>按定义的位置来分</p><ol><li><strong>成员内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。<strong>（常用）</strong></li></ol><h2 id="1-3-成员内部类"><a href="#1-3-成员内部类" class="headerlink" title="1.3 成员内部类"></a>1.3 成员内部类</h2><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类。 <span class="comment">// 访问内部类的类型都是用 外部类.内部类</span></span><br></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 变量 = <span class="keyword">new</span> 外部类（）.new 内部类（）;</span><br></pre></td></tr></table></figure><p>方式二：在外部类中定义一个方法提供内部类的对象</p><h2 id="1-4-成员内部类的细节"><a href="#1-4-成员内部类的细节" class="headerlink" title="1.4 成员内部类的细节"></a>1.4 成员内部类的细节</h2><p>编写成员内部类的注意点：</p><ol><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730213524999.png" alt="image-20220730213524999"></p><p>详解：</p><p>​内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象</p><p>​被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象</p><p>​内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。</p><p>​内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。</p><h2 id="1-5-静态内部类"><a href="#1-5-静态内部类" class="headerlink" title="1.5 静态内部类"></a>1.5 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li>静态内部类是一种特殊的成员内部类。</li></ul><ul><li>有static修饰，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</li><li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</li><li><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730213730857.png" alt="image-20220730213730857"></p><p><strong>内部类的使用格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类。</span><br></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类  变量 = <span class="keyword">new</span>  外部类.内部类构造器;</span><br></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730213801121.png" alt="image-20220730213801121"></p><h2 id="1-6-局部内部类"><a href="#1-6-局部内部类" class="headerlink" title="1.6 局部内部类"></a>1.6 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730213859003.png" alt="image-20220730213859003"></p><p>定义格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class 外部类名 &#123;</span><br><span class="line">数据类型 变量名;</span><br><span class="line"></span><br><span class="line">修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">class 内部类 &#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-匿名内部类【重点】"><a href="#1-7-匿名内部类【重点】" class="headerlink" title="1.7 匿名内部类【重点】"></a>1.7 匿名内部类【重点】</h2><h3 id="1-7-1-概述"><a href="#1-7-1-概述" class="headerlink" title="1.7.1 概述"></a>1.7.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="1-7-2-格式"><a href="#1-7-2-格式" class="headerlink" title="1.7.2 格式"></a>1.7.2 格式<img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730214254912.png" alt="image-20220730214254912"></h3><h3 id="1-7-2-什么时候用到匿名内部类"><a href="#1-7-2-什么时候用到匿名内部类" class="headerlink" title="1.7.2 什么时候用到匿名内部类"></a>1.7.2 什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。 </p><p>之前我们使用接口时，似乎得做如下几步操作：</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗刨式...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 4. 调用方法</span></span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="1-7-3-匿名内部类前提和格式"><a href="#1-7-3-匿名内部类前提和格式" class="headerlink" title="1.7.3 匿名内部类前提和格式"></a>1.7.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-7-4-使用方式"><a href="#1-7-4-使用方式" class="headerlink" title="1.7.4 使用方式"></a>1.7.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;自由泳...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.swimming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        s2.swimming();</span><br><span class="line">        s2.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-5-匿名内部类的特点"><a href="#3-9-5-匿名内部类的特点" class="headerlink" title="3.9.5 匿名内部类的特点"></a>3.9.5 匿名内部类的特点</h3><ol><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="3-9-6-匿名内部类的使用场景"><a href="#3-9-6-匿名内部类的使用场景" class="headerlink" title="3.9.6 匿名内部类的使用场景"></a>3.9.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方式传入对象</span></span><br><span class="line">        <span class="comment">// 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        </span><br><span class="line">        goSwimming(s);</span><br><span class="line">        <span class="comment">// 匿名内部类使用场景:作为方法参数传递</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蝶泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 传入匿名内部类</span></span><br><span class="line">        goSwimming(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完美方案: 一步到位</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大学生, 蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小学生, 自由泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,模拟请一些人去游泳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swim s)</span> &#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730220807713.png" alt="image-20220730220807713"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法重载、代码块</title>
      <link href="/2020/07/27/java/day10-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
      <url>/2020/07/27/java/day10-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java方法重载规则："><a href="#1-Java方法重载规则：" class="headerlink" title="1.Java方法重载规则："></a>1.Java方法重载规则：</h1><p>1、方法名必须一致</p><p>2、参数列表必须不一致（参数类型、参数个数、参数排列顺序）</p><p>3、方法的返回类型可以相同也可以不同</p><p>4、只是返回类型不同不是方法重载</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220727144339131.png" alt="image-20220727144339131"></p><p>首先，方法名都是fire，保持一致；其次，保证参数列表类型不同。例子中，在方法名相同的情况下，编译器会根据调用方法的参数个数，参数类型进行逐个匹配，从而选择对应的方法。</p><h1 id="2-介绍return、break、continue的区别"><a href="#2-介绍return、break、continue的区别" class="headerlink" title="2.介绍return、break、continue的区别"></a>2.介绍return、break、continue的区别</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220727144415815.png" alt="image-20220727144415815"></p><h1 id="3-代码块概念"><a href="#3-代码块概念" class="headerlink" title="3.代码块概念"></a>3.代码块概念</h1><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730105532784.png" alt="image-20220730105532784" style="zoom:50%;" /><p>分为三类：</p><ul><li><p><strong>局部代码块</strong>（淘汰了）</p></li><li><p><strong>构造代码块</strong>（也不用了）</p></li><li><p><strong>静态代码块</strong>（重点）</p></li></ul><h1 id="4-局部代码块"><a href="#4-局部代码块" class="headerlink" title="4.局部代码块"></a>4.局部代码块</h1><p>写在方法里的单独的大括号</p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730105901065.png" alt="image-20220730105901065" style="zoom:50%;" /><h1 id="5-构造代码块"><a href="#5-构造代码块" class="headerlink" title="5.构造代码块"></a>5.构造代码块</h1><p>1.写在成员位置的代码块</p><p>2.作用：可以把多个构造方法中重复的代码抽取出来</p><p>3.执行时机：我们在创建本类对象的时候<strong>先执行构造代码块再执行构造方法</strong></p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730110347748.png" alt="image-20220730110347748" style="zoom:50%;" /><p>看上面两张图，重复了一个打印语句，这时候我们就可以用一个代码块整合到一起。写在构造代码块中。</p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730110003315.png" alt="image-20220730110003315" style="zoom:50%;" /><p>现在常用的用法：</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730111815678.png" alt="image-20220730111815678"></p><h1 id="6-静态代码块"><a href="#6-静态代码块" class="headerlink" title="6.静态代码块"></a>6.静态代码块</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730111953615.png" alt="image-20220730111953615"></p><p>就是在构造代码块的前面加了一个static，比如说用户管理界面，在程序刚开始的时候，做一些数据初始化。</p><p>static再调用方法的时候，调用的方法也必须是static方法。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730113140390.png" alt="image-20220730113140390"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的修饰符、枚举、抽象类</title>
      <link href="/2020/07/16/java/day09-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2020/07/16/java/day09-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-java的权限修饰符"><a href="#1-java的权限修饰符" class="headerlink" title="1.java的权限修饰符"></a>1.java的权限修饰符</h1><h2 id="1-1权限修饰符："><a href="#1-1权限修饰符：" class="headerlink" title="1.1权限修饰符："></a>1.1权限修饰符：</h2><h2 id="是用来控制一个成员能够访问的范围"><a href="#是用来控制一个成员能够访问的范围" class="headerlink" title="是用来控制一个成员能够访问的范围"></a>是用来控制一个成员能够访问的范围</h2><p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</p><ul><li>四种范围从小到大（<strong>private &lt; 缺省(没有修饰符) &lt; protected &lt; public</strong>（任何地方都可以访问））</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220709161656386.png" alt="image-20220709161656386"></p><p>一般我们如何要求：（规范）</p><ul><li>成员变量一般私有（private）</li><li>方法一般公开（public）</li><li>如果该成员只希望本类访问，使用private修饰（private）</li><li>如果该成员只希望本类，同一个包下的其他类和子类访问，使用protect修饰。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730105251866.png" alt="image-20220730105251866"></p><h1 id="2-final"><a href="#2-final" class="headerlink" title="2.final"></a>2.final</h1><h2 id="2-1final的作用"><a href="#2-1final的作用" class="headerlink" title="2.1final的作用"></a>2.1final的作用</h2><ul><li>final关键字是最终的意思，可以修饰（类、方法、变量）</li><li>修饰类：表明该类是最终类，不能被继承</li><li>修饰方法：表明该方法是最终方法，不能被重写</li><li>修饰变量：表明该变量第一次赋值后，不能再次被赋值（有且只有仅能被赋值一次）</li></ul><h2 id="2-2final修饰变量的注意"><a href="#2-2final修饰变量的注意" class="headerlink" title="2.2final修饰变量的注意"></a>2.2final修饰变量的注意</h2><ul><li>final修饰的变量是基本类型：那么变量存储的数据值不能发生改变。</li><li>final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，但是地址指向的对象内容是可以发生变化的。</li></ul><h1 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h1><p>常量是使用public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。</p><p>变量的作用和好处：可以用于做系统的配置信息，方便程序的危害，同时也提高可读性。</p><ul><li>常量命名规范：英文单词全部大写。</li><li>多个单词下划线连接起来。</li></ul><p>好处就是：如果修改了变量不用到处都修改，比如说学校名称具有唯一性，万一哪天学校改名。不用到处修改，改那个常量就好了。</p><ul><li>一处定义多处使用</li></ul><p>常量的执行原理：</p><ul><li>在编译阶段会进行“宏替换”，把使用常量的地方全部替换真实的字面量。</li><li>这样做的好处是让使用常量的程序的执行性能与直接使用字母量是一样的。</li><li>代码可读性好，实现了软编码形式</li></ul><h1 id="4-枚举的概述"><a href="#4-枚举的概述" class="headerlink" title="4.枚举的概述"></a>4.枚举的概述</h1><h2 id="4-1枚举是Java中的一种特殊类型（类似数组）"><a href="#4-1枚举是Java中的一种特殊类型（类似数组）" class="headerlink" title="4.1枚举是Java中的一种特殊类型（类似数组）"></a>4.1枚举是Java中的一种特殊类型（类似数组）</h2><ul><li>枚举的作用：<strong>是为了做信息的标志和信息的分类。</strong></li></ul><h2 id="4-2定义枚举类的格式"><a href="#4-2定义枚举类的格式" class="headerlink" title="4.2定义枚举类的格式"></a>4.2定义枚举类的格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="comment">//枚举的第一行必须全部罗列枚举类的对象名称，建议全部大写。</span></span><br><span class="line">    Spring,Summer,Autumn,Winter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3枚举的特征"><a href="#4-3枚举的特征" class="headerlink" title="4.3枚举的特征"></a>4.3枚举的特征</h2><ul><li>枚举类都是继承了枚举类型：java.lang.Enum</li><li>枚举都是最终类，不可以被继承</li><li>枚举类的构造器都是私有的，枚举对外不能创建对象。</li><li>枚举类的第一行默认都是罗列枚举对象的名称的。</li><li>枚举类相当于是多例模式。</li></ul><h2 id="4-4枚举做信息标志和分类"><a href="#4-4枚举做信息标志和分类" class="headerlink" title="4.4枚举做信息标志和分类"></a>4.4枚举做信息标志和分类</h2><p>建议使用，因为代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！建议使用！（但是项目中好多还是用常量比较多，因为简单，能跑就行）</p><h1 id="5-抽象类"><a href="#5-抽象类" class="headerlink" title="5.抽象类"></a>5.抽象类</h1><p>简单来说就是一个设计稿，不在里面设计，只是一个蓝图，别的类照着这个蓝图重写方法。</p><h2 id="5-1抽象类说明"><a href="#5-1抽象类说明" class="headerlink" title="5.1抽象类说明"></a>5.1抽象类说明</h2><p>抽象类：不能使用new关键字来创建对象，他是用来让子类继承的。<strong>约束。</strong></p><p>抽象方法：只有方法的声明，没有方法的实现，它是用来让子类实现的。</p><p>抽象类的作用：抽取共性时，无法确定方法体，就把方法定义为抽象的。</p><h2 id="5-2特征和注意事项："><a href="#5-2特征和注意事项：" class="headerlink" title="5.2特征和注意事项："></a>5.2特征和注意事项：</h2><ul><li>类有的成员（成员变量、方法、构造器）抽象类都具备</li><li>抽象类不能被实例化（不能创建对象）</li><li>可以有构造方法</li><li>抽象类不一定有抽象方法，但有抽象方法一定有抽象类。(爸爸不一定有孩子，孩子肯定有爸爸)</li><li>抽象类的子类有哪些注意？：（1.要么重写抽象类中的所有抽象方法。(通常第一种)  2.要么是抽象类）</li><li>不能用abstract修饰变量、代码块、构造器。（没有括号）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730173337703.png" alt="image-20220730173337703"><br>上图我们可以知道定义一个接口，可以让下面的人好写，如果每个人都写一个方法，但是方法的名称千奇百怪，就会很麻烦，调用就会很痛苦。<br>（强制子类必须安装这种格式重写，统一的概念）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void pay(double money);</span><br></pre></td></tr></table></figure><ul><li>最重要的特征：得到了抽象方法、失去了创建对象的能力（有得有失）</li></ul><p>人话：这个抽象了，所以就不能实例化，存在的意义就是提高开发效率。</p><h2 id="5-3final和abstract是互斥关系"><a href="#5-3final和abstract是互斥关系" class="headerlink" title="5.3final和abstract是互斥关系"></a>5.3<strong>final和abstract是互斥关系</strong></h2><p>abstract定义的抽象类作为模版让子类继承，final定义的类不能被继承。</p><h1 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h1><h2 id="6-1格式："><a href="#6-1格式：" class="headerlink" title="6.1格式："></a>6.1格式：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public interface 接口名&#123;</span><br><span class="line">    //常量</span><br><span class="line">    //抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类只能单继承，接口可以多继承。</p></li><li><p>接口就是体现规范的思想；约束。 </p></li><li><p>规范一定是公开的，别人才知道。所以用public。</p></li></ul><h2 id="6-2常量格式"><a href="#6-2常量格式" class="headerlink" title="6.2常量格式"></a>6.2常量格式</h2><ul><li>常量是一定要进行初始化的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;北京大学&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="6-3抽象方法"><a href="#6-3抽象方法" class="headerlink" title="6.3抽象方法"></a>6.3抽象方法</h2><p>由于接口体现规范思想，默认公开的。所以代码层面public abstract<strong>可以省略不写。</strong></p><ul><li>接口是类似抽象类。所以有abstract</li><li>接口是一种规范，公开的，所以是public</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract void run();</span><br><span class="line">= void run();</span><br></pre></td></tr></table></figure><p>所以常量也是<strong>可以省略不写。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final String SCHOOL_NAME = &quot;北京大学&quot;;</span><br><span class="line">= String SCHOOL_NAME = &quot;北京大学&quot;;</span><br></pre></td></tr></table></figure><p>但是是在接口里的，这样才知道不是普通的常量。</p><h2 id="6-4接口中成员的特点："><a href="#6-4接口中成员的特点：" class="headerlink" title="6.4接口中成员的特点："></a>6.4接口中成员的特点：</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730191452332.png" alt="image-20220730191452332"></p><h2 id="6-5接口的基本使用：被实现"><a href="#6-5接口的基本使用：被实现" class="headerlink" title="6.5接口的基本使用：被实现"></a>6.5接口的基本使用：被实现</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730184904004.png" alt="image-20220730184904004"></p><ul><li>接口是用来被<strong>类实现的（implements）</strong>的，实现接口的类被称为<strong>实现类</strong>，实现类可以理解成所谓的子类。</li></ul><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class 实现类 implements 接口1,接口2... &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">实现的关键字：implements</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730185025361.png" alt="image-20220730185025361"></p><p>从上面也可以看出，接口可以被类单实现，也可以被类多实现。</p><ul><li><p>接口实现的注意事项：</p><p>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。</p></li></ul><h2 id="6-5小结"><a href="#6-5小结" class="headerlink" title="6.5小结"></a>6.5小结</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220730194610783.png" alt="image-20220730194610783"></p><p>类和类的关系：单继承</p><p>类和接口的关系：多实现</p><p>接口和接口的关系：多继承，一个接口可以继承多个接口</p><ul><li>多继承的作用：规范合并，整合多个接口为同一个接口，便于子类实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的继承、重写、static</title>
      <link href="/2020/07/14/java/day08-%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81static/"/>
      <url>/2020/07/14/java/day08-%E7%BB%A7%E6%89%BF%E3%80%81%E9%87%8D%E5%86%99%E3%80%81static/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是继承"><a href="#1-什么是继承" class="headerlink" title="1.什么是继承"></a>1.什么是继承</h1><p>Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。</p><p>Student称为子类（派生类），People称为父类。如果不使用继承那么则会使用大量的重复性代码。</p><p>作用：当子类继承父类后，就可以直接用父类公共的属性和方法。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728212954110.png" alt="image-20220728212954110"></p><h2 id="1-1使用继承的好处："><a href="#1-1使用继承的好处：" class="headerlink" title="1.1使用继承的好处："></a>1.1使用继承的好处：</h2><ul><li><p>可以提高代码的复用性，减少代码冗余，增强类的功能扩展性</p></li><li><p>继承就是Java允许我们用extends关键字，让一个类和另一类建立起一种父子关系</p></li></ul><h2 id="1-2继承的格式"><a href="#1-2继承的格式" class="headerlink" title="1.2继承的格式"></a>1.2继承的格式</h2><ul><li>子类 extends 父类</li></ul><h2 id="1-3继承后子类的特点"><a href="#1-3继承后子类的特点" class="headerlink" title="1.3继承后子类的特点"></a>1.3继承后子类的特点</h2><ul><li>子类继承父类，子类可以得到父类的属性和行为，子类可以使用。</li><li>Java中子类更强大。</li></ul><h1 id="2-继承的设计和规范、内存运行原理"><a href="#2-继承的设计和规范、内存运行原理" class="headerlink" title="2.继承的设计和规范、内存运行原理"></a>2.继承的设计和规范、内存运行原理</h1><h2 id="2-1继承设计规范"><a href="#2-1继承设计规范" class="headerlink" title="2.1继承设计规范"></a>2.1继承设计规范</h2><p>子类们相同特征（共性属性，共性方法）放在父类中定义，子类独有属性和行为应该定义在子类自己里面。</p><h2 id="2-2为什么？"><a href="#2-2为什么？" class="headerlink" title="2.2为什么？"></a>2.2为什么？</h2><p>如果子类的独有属性、行为定义在父类中，会导致其他子类也会得到这些属性和行为，这不符合面向对象逻辑。</p><h1 id="3-继承的特点"><a href="#3-继承的特点" class="headerlink" title="3.继承的特点"></a>3.继承的特点</h1><p>3.1子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。</p><ul><li>子类有自己的构造器，父类构造器用于初始化对象。</li><li>子类可以继承父类的私有成员，只是不能直接访问。（继承了但是没完全继承）</li><li>子类是否可以继承父类的静态成员：可以使用，但不能算继承（共享并非继承）</li></ul><p>3.2Java是单继承模式，一个类只能继承一个直接父类</p><p>一个孩子一个爸</p><p>3.3java不支持多继承，但是支持多层继承</p><p>爸爸可以有爷爷，比如所有类都继承Object类。</p><p>3.4Java中所有的类都是Object的子类</p><p>默认继承Object类。Object类祖宗类。</p><h1 id="4-继承后：成员变量，成员方法的访问特点"><a href="#4-继承后：成员变量，成员方法的访问特点" class="headerlink" title="4.继承后：成员变量，成员方法的访问特点"></a>4.继承后：成员变量，成员方法的访问特点</h1><h2 id="4-1就近原则"><a href="#4-1就近原则" class="headerlink" title="4.1就近原则"></a>4.1就近原则</h2><ul><li>先子类局部范围找，然后父类范围找。（先子类后父类）</li><li>如果出现重名的话，会优先使用子类的。如果一定要在子类中使用父类的。</li><li><ul><li>可以通过super关键字，指定访问父类的成员。</li><li>格式：super.父类成员变量&#x2F;父类成员方法</li><li>指定访问子类对象加this，父类对象加super</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728214457484.png" alt="image-20220728214457484"></p><h1 id="5-方法重写"><a href="#5-方法重写" class="headerlink" title="5.方法重写"></a>5.方法重写</h1><h2 id="5-1是什么方法重写？"><a href="#5-1是什么方法重写？" class="headerlink" title="5.1是什么方法重写？"></a>5.1是什么方法重写？</h2><p>在继承体系中，子类出现了和父类中一摸一样的方法声明，我们就称子类这个方法是重写的方法。</p><h2 id="5-2方法重写的应用场景"><a href="#5-2方法重写的应用场景" class="headerlink" title="5.2方法重写的应用场景"></a>5.2方法重写的应用场景</h2><p>当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。子类就可以重写父类中的方法。（比如父类有一辆车，子类也想要，然后买了一辆，想开谁的车都可以，还可以加音箱之类的功能）</p><p>比如手机原来只能打电话，现在还能打视频。加个视频的功能。</p><h2 id="5-3-Override重写注解"><a href="#5-3-Override重写注解" class="headerlink" title="5.3@Override重写注解"></a>5.3@Override重写注解</h2><p>@Override重写是放在重写的方法后，作为重写是否正确的校验注解</p><ul><li>加上该注解如果重写错误，编译阶段则会出现提示</li><li>加上别人就知道你这是重写方法，不然还以为有个新方法。代码安全，优雅。</li></ul><h2 id="5-4方法重写注意事项和要求"><a href="#5-4方法重写注意事项和要求" class="headerlink" title="5.4方法重写注意事项和要求"></a>5.4方法重写注意事项和要求</h2><ul><li>重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。就是名称要一样，有参无参不能乱写。不然不知道重写方法。</li><li>私有方法不能重写。不然认识是新方法。</li><li>子类重写时，访问权限必须大于或者等于父类，（暂时了解，缺省&lt;protected&lt;public） 修饰符public最大，子类可以写public，父类不写也可以，权限大。 意义不大。最好写一样。</li><li>子类不能重写父类的静态方法，如果重写会报错（public static ….）</li></ul><h1 id="6-构造器特点"><a href="#6-构造器特点" class="headerlink" title="6.构造器特点"></a>6.构造器特点</h1><p>子类继承父类后构造器的特点：</p><ul><li>子类中所有的构造器默认都会先访问父类中无参的构造器 ，再执行自己。（先爸爸后孩子）</li></ul><p>为什么：</p><ul><li>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。</li><li>子类初始化之前，一定要调用父类构造器先完成父类数据空间中的初始化。</li></ul><p>因为子类构造器的第一行语句默认都是super（），不写也存在。<strong>super()</strong></p><h1 id="7-this和super"><a href="#7-this和super" class="headerlink" title="7.this和super"></a>7.this和super</h1><p>This:代表本类对象的引用；</p><p>super：代表父类存储空间的标识；</p><p>this和super都只能放在构造器的第一行，所以两者不能共存在一个构造器中。 </p><ul><li>类的5大成分（成员变量、成员方法、构造器、代码块、内部类）</li></ul><h1 id="8-static-静态关键字"><a href="#8-static-静态关键字" class="headerlink" title="8.static(静态关键字)"></a>8.static(静态关键字)</h1><ul><li>8.1被static修饰的成员属于类、类成员。静态成员。通过（类.成员）方式来调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int a = 2;</span><br><span class="line">static void m()&#123;</span><br><span class="line">    System.out.println(20);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(A.a);</span><br><span class="line">    A.m();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>8.2不被static修饰的成员属于<strong>对象</strong>、对象成员。非静态成员，通过（对象.成员）方式来调用。</li><li>8.3静态成员可以被所有对象共享（不建议使用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">n</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(t.b);</span><br><span class="line">    t.n();</span><br></pre></td></tr></table></figure><p>从中我们多了一步，A t &#x3D; new A();new 了一个对象。不被static修饰的成员属于<strong>对象</strong>。main函数里没有对象，所以我们要new一个对象。（t就是那个对象）。</p><p><strong>所以没有static都是要new一个对象</strong></p><ul><li>8.3静态成员可以所有对象共享。</li></ul><h1 id="9-Java注释——-x2F-x2F-、-x2F-x2F-、-x2F-x2F"><a href="#9-Java注释——-x2F-x2F-、-x2F-x2F-、-x2F-x2F" class="headerlink" title="9.Java注释——&#x2F;&#x2F;、&#x2F;* &#x2F;、&#x2F; **&#x2F;"></a>9.Java注释——&#x2F;&#x2F;、&#x2F;* <em>&#x2F;、&#x2F;</em> **&#x2F;</h1><p>Java注释的三种类型</p><p>1、单选注释：符号是：&#x2F;&#x2F;<br>2、块注释： 符号是： &#x2F;* <em>&#x2F; 可以跨多行（多行的&#x2F;&#x2F;）<br>3、javadoc注释： 符号是： &#x2F;</em>* *&#x2F; 可以跨多行，（和前两者不一样）<br>生成javadoc时，这样的注释会被生成标准的java api注释。</p><p>&#x2F;* **&#x2F;注释的话，你在调用类和方法的时候会出现提示，内容就是你写的注释。<br>而&#x2F;* <em>&#x2F;就没有了。&#x2F;</em> *&#x2F;就是&#x2F;&#x2F;的多行版</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法</title>
      <link href="/2020/07/06/java/day06-%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/06/java/day06-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>啥是面向对象？</p><p>面向：找、拿。</p><p>对象：东西。</p><p>面向对象编程：找或拿东西过来编程。</p><h2 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h2><p>如果要用对象，必须先设计类，创建对象并使用</p><p>类（设计图）：是对象共同特征的描述；</p><p>对象：是真实存在的具体实例。 </p><p><strong>结论：在Java中，必须先设计类，才能创建对象并使用。</strong></p><h3 id="2-1如何设计类"><a href="#2-1如何设计类" class="headerlink" title="2.1如何设计类"></a>2.1如何设计类</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/%E7%B1%BB.png" alt="类"></p><p>案例：</p><p>定义一个Car类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javabean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">/*成员变量*/</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;启动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;价格是&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类调用Car类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javabean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建汽车对象</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        c.name = <span class="string">&quot;bwm&quot;</span>;</span><br><span class="line">        c.price = <span class="number">465</span>;</span><br><span class="line">        c.start();</span><br><span class="line">        c.run();</span><br><span class="line"></span><br><span class="line">        <span class="type">Car</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idea中的f：field(类的属性)</p><p>m:method(方法)</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220704155004410.png" alt="image-20220704155004410"></p><h3 id="2-2类的补充"><a href="#2-2类的补充" class="headerlink" title="2.2类的补充"></a>2.2类的补充</h3><p>1.类名要大写，不能用关键字，驼峰模式，合法标识，且有意义</p><p>2.一个Java文件中可以定义多个class类，但只能有一个public类，其他的类不能加public，并且，public修饰的类必须成为代码文件名。</p><p>重要：所以实际开发还是建议一个代码文件定义一个类</p><p>3.成员变量的完整定义格式是：修饰符 数据类型 变量名称 &#x3D; 初始化值；</p><p>一般无需指定初始值，存在默认值。</p><p><strong>默认值的规则：</strong></p><p>byte short int long :   0</p><p>double float :  0.0</p><p>Boolean : false</p><p>String : null</p><p>例子：</p><p>通常写的：String name；</p><p>实际上：String name &#x3D; null；（null是系统默认的）</p><h2 id="3-构造器-有参和无参"><a href="#3-构造器-有参和无参" class="headerlink" title="3.构造器(有参和无参)"></a>3.构造器(有参和无参)</h2><h3 id="3-1构造器的作用"><a href="#3-1构造器的作用" class="headerlink" title="3.1构造器的作用"></a>3.1构造器的作用</h3><p>定义在类的，可以用于初始化一个类的对象，并<strong>返回对象的地址。****说白了，可以通过它得到一个对象</strong></p><ul><li>初始化类的对象，并返回对象的地址。</li></ul><p>Car c &#x3D; new Car();</p><h3 id="3-2构造器的使用"><a href="#3-2构造器的使用" class="headerlink" title="3.2构造器的使用"></a>3.2构造器的使用</h3><p>无参构造器，默认存在的。</p><p>有参构造器，在初始化对象的时候，<strong>同时可以接受参数为对象进行赋值。</strong></p><p>案例：</p><p>创建一个Shop类，定义有参无参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Shop</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Shop</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是有参&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个People类，使用Shop类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>();</span><br><span class="line">    s.name = <span class="string">&quot;无参，括号里没函数&quot;</span>;</span><br><span class="line">    s.price = <span class="number">120</span>;</span><br><span class="line">    System.out.println(s.name);</span><br><span class="line">    System.out.println(s.price);</span><br><span class="line"></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(<span class="string">&quot;有参&quot;</span>,<span class="number">130</span>);</span><br><span class="line">    System.out.println(s1.price);</span><br><span class="line">    System.out.println(s1.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s里面new Shop里没有参数，对应无参</p><p>s1里面new Shop里有参数，对应有参</p><h3 id="额外知识：Double-和-double"><a href="#额外知识：Double-和-double" class="headerlink" title="额外知识：Double 和 double"></a>额外知识：Double 和 double</h3><ol><li>double是基本数据类型，不是一个类；Double是原始数据类型，是一个类，Object的一个子类</li><li>double没有方法，Double有自己的属性和方法</li><li>double只创建引用，Double创建对象</li><li>集合类不能存放double，只能存放Double</li><li>两者存放位置不同：</li><li>Double 整数报错，double则不会</li></ol><h3 id="3-3构造器的注意事项"><a href="#3-3构造器的注意事项" class="headerlink" title="3.3构造器的注意事项"></a>3.3构造器的注意事项</h3><p>任何类定义出来，默认就自带了无参数构造器，写不写都有。</p><ul><li>但是一旦定义了有参数构造器，无参数构造器就没有了，如果还想用无参数构造器，此时就需要自己手写一个无参数构造器了。否则报错</li></ul><h2 id="4-this关键字"><a href="#4-this关键字" class="headerlink" title="4.this关键字"></a>4.this关键字</h2><h3 id="4-this关键字是什么"><a href="#4-this关键字是什么" class="headerlink" title="4.this关键字是什么"></a>4.this关键字是什么</h3><ul><li>可以出现在构造器、方法中</li><li>代表当前对象的地址</li><li>在构造器无参中，已经出现了this，（虽然是自动生成的）</li><li>this（可以理解为当前对象的成员变量，而不是形参）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Shop</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是有参&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//加了this是给当前的对象，不加是另一边传过来的形参</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">//取了一个名称叫name，传给了当前对象的name</span></span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>this是调用对象赋值，不加是直接复制。指定当前对象，好区分分。</p><h2 id="5-封装"><a href="#5-封装" class="headerlink" title="5.封装"></a>5.封装</h2><p>面向对象的三大特征：封装、继承、多态。</p><p><strong>封装的原则；对象代表什么，就得封装对应的数据，并提供对应数据的行为。</strong></p><p>比如人开车，但是“开”是定义在车的方法里，车都会被开，但是人不一定开车。人只是调用这个方法。</p><p>封装思想：可以省下很多的事，大部分常用的方法Sun公司都会提供，不用自己去写了，找到对应的方法就好了。如果实在没用，只能自己写了。</p><p>有什么事，找对象，调方法就行了。</p><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</p><h3 id="5-1如何更好的封装"><a href="#5-1如何更好的封装" class="headerlink" title="5.1如何更好的封装"></a>5.1如何更好的封装</h3><p>1.一般建议使用对private（私有、隐藏）关键字修饰。（private修饰的成员只能 在当前类中进行访问）</p><p>2.为每个成员变量提供配套public修饰的getter和setter方法。</p><p>可以在setter里输入条件，满足条件</p><p>所得到的结果都要用条件满足。</p><p>输入值：fan.setAge(30);（对象名.方法名()）</p><p>输出值：System.out.println(fan.getAge());</p><ul><li>“&amp;&amp;”表示 与，意为同时都要满足。“||”表示 或，意为二者或多着只要满足其中一个。</li></ul><h2 id="6-Java-Bean"><a href="#6-Java-Bean" class="headerlink" title="6.Java Bean"></a>6.Java Bean</h2><p>也可以称为实体类，其对象可以用于程序中封装数据。</p><ul><li>用于实体类（学生类、老师类、汽车类），不是什么test类，</li></ul><p>标准JavaBean必须满足如下要求</p><p>1.成员变量使用private修饰</p><p>2.提供成员变量对应的set&#x2F;get方法，暴露其赋值(可能会觉得有set方法要校验加判断，因为数据可能不安全。但是因为数据传过来就已经是一个合法的判断。所以没必要，可以写但没必要)</p><p>3.必须提供一个无参构造器，有参构造器可写可不写。（但是写了有参，必须要写无参）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private String name;</span><br><span class="line">//无参</span><br><span class="line">public User() &#123;</span><br><span class="line">&#125;</span><br><span class="line">//有参</span><br><span class="line">public User(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">//get和set方法</span><br><span class="line">public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1set和get"><a href="#6-1set和get" class="headerlink" title="6.1set和get"></a>6.1set和get</h3><p>setName 和 getName只是两个标识符，代表方法。</p><ul><li><strong>setName用来设置的，getName用来获取的</strong>。</li></ul><p>getName，因为name是private不能在其他类中直接获取</p><p>你在一个类里面写的main方法，可以直接访问私有属性，要在外面创建对象，赋值后要通过get方法才能访问属性</p><h2 id="7-补充：成员变量和局部变量"><a href="#7-补充：成员变量和局部变量" class="headerlink" title="7.补充：成员变量和局部变量"></a>7.补充：成员变量和局部变量</h2><p>成员变量：在类中（class类），int age;<strong>默认值0</strong>。堆内存。<strong>对象创建存在</strong></p><p>局部变量：在方法中（main），int age &#x3D; 18;<strong>没有默认值要定义</strong>。栈内存。<strong>方法运行存在</strong></p><p>局部变量的作用域在main方法的大括号里，跳出括号就没有了，成员变量则不好界定。</p><h1 id="8-类、对象、方法"><a href="#8-类、对象、方法" class="headerlink" title="8.类、对象、方法"></a>8.类、对象、方法</h1><p>类是封装对象的属性和行为的载体，而对象的方法以成员方法的形式存在，类是构建对象的模板。</p><p>对象是类的具体实例。</p><p>人话：类是一个模版（<strong>属性和行为</strong>），比如动物类，动物有姓名，年龄。这就是属性，动物会跑会叫，这是<strong>方法（类方法）</strong>，这也是它的行为。</p><p>对象是个具体的实例，比如加菲猫，姓名叫加菲猫，跑的慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat 加菲猫 = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br></pre></td></tr></table></figure><p>对象则是new这个类取的一个叫加菲猫的名称。</p><h1 id="9-成员变量和局部变量"><a href="#9-成员变量和局部变量" class="headerlink" title="9.成员变量和局部变量"></a>9.成员变量和局部变量</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728065751923.png" alt="image-20220728065751923"></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220727204239462.png" alt="image-20220727204239462"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven基础知识</title>
      <link href="/2020/07/06/java/day07-Maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/06/java/day07-Maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1.Maven简介"></a>1.Maven简介</h1><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><p>1.1提供了一套标准化的项目结构</p><ul><li>不同的IDE之间，项目结构不一样，不通用。</li></ul><p><strong>Maven提供了一套标准化的项目结构，所有IDE使用Maven构建的项目结构完全一样，所有IDE创建的Maven项目可以通用。</strong>（这样大家都使用通用的模版，更容易理解）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/WX20220706-162504@2x.png" alt="WX20220706-162504@2x"></p><p>1.2提供了一套标准化的构建流程（编译，测试，打包，发布…..）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/WX20220706-162659@2x.png" alt="WX20220706-162659@2x"></p><p><strong>Maven提供了一套简单的命令来完成项目构建</strong>（自己虽然也可以做，但是很琐碎）</p><p>**1.3&lt;提供了一套依赖管理机制**&gt;</p><p>依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件…..）</p><p>通俗点说：还是为了方便，之前所做的一般来说三步：1.下载jar包。2.复制jar包到项目。3.将jar包加入工作环境。</p><p>但是jar包多了以后就很麻烦，而且jar包下载也很头痛。也是Maven最重要的</p><p><strong>maven是一个管理jar包直接上坐标就能自动下载对应jar包的工具，通过坐标来下载。</strong></p><h1 id="2-Maven常用命令"><a href="#2-Maven常用命令" class="headerlink" title="2.Maven常用命令"></a>2.Maven常用命令</h1><p>compile：编译</p><p>clean：清理</p><p>test：测试</p><p>package：打包</p><p>Install：安装</p><h2 id="2-1Maven生命周期"><a href="#2-1Maven生命周期" class="headerlink" title="2.1Maven生命周期"></a>2.1Maven生命周期</h2><p>Maven构建项目生命周期描述的是一次构建过程经历经历多少个事件</p><p>Maven对项目构建的生命周期划分为三套</p><p>clean：清理工作</p><p>default：核心工作，例如编译，测试，打包，安装等</p><p>site：产生报告，发布站点</p><h1 id="3-IDEA配置Maven"><a href="#3-IDEA配置Maven" class="headerlink" title="3. IDEA配置Maven"></a>3. IDEA配置Maven</h1><h2 id="3-1-IDEA配置Maven环境"><a href="#3-1-IDEA配置Maven环境" class="headerlink" title="3.1 IDEA配置Maven环境"></a>3.1 IDEA配置Maven环境</h2><p> 导入即可，太简单了，设置里有</p><h2 id="3-2-Maven坐标详解"><a href="#3-2-Maven坐标详解" class="headerlink" title="3.2 Maven坐标详解"></a>3.2 Maven坐标详解</h2><p>1.什么是坐标：</p><p>Maven中的坐标是资源的唯一标识</p><p>使用坐标来定义项目或引入项目中所需要的依赖</p><p>2.Maven坐标组成</p><ul><li><p><strong>groupld：</strong>定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.baidu）</p></li><li><p><strong>artifactld：</strong>定义当前Maven项目名称（通常是模块名称，例如order-service、goods-service）</p></li><li><p><strong>version：</strong>定义当前项目版本号。 例如1.1都可以</p></li></ul><p>2.导入idea</p><p>这里只需要导入Maven 的pom文件就可以了，不需要导入项目</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220706172502068.png" alt="image-20220706172502068"></p><h1 id="4-依赖管理"><a href="#4-依赖管理" class="headerlink" title="4.依赖管理"></a>4.依赖管理</h1><p>第一步是进入pom文件，首先查看我们项目的坐标</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220706172958070.png" alt="image-20220706172958070"></p><p>我们所有的jar包都是在dependencies</p><p>导包设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入mysql 驱动jar包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">8.0</span><span class="number">.29</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在依赖项可以查看到，但记得要刷新maven项目，或者是自己添加依赖项，command+n，输入自己所添加的jar包名称，（好处是不用输代码，直接生成,但往往会出来一堆，要自己记住版本号，有些不是很好找）</p><h2 id="4-1依赖范围"><a href="#4-1依赖范围" class="headerlink" title="4.1依赖范围"></a>4.1依赖范围</h2><p>通过设置坐标的依赖范围（scope）可以设置对应jar包的作用范围：<strong>编译环境、测试环境、运行环境</strong>。简单的说，我添加了这个scope，我想让哪个包就用让哪个类用。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220706204406585.png" alt="image-20220706204406585"></p><p>此外也可以设置依赖范围，但大多情况默认就好。<strong>多了不如少了</strong></p><p>简单的一些Maven基础知识就这么多了。</p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 多态</title>
      <link href="/2020/05/30/java/day14-%E5%A4%9A%E6%80%81/"/>
      <url>/2020/05/30/java/day14-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h1><ul><li><p><strong>调用成员变量时：编译看左边，运行看左边</strong></p></li><li><p><strong>调用成员方法时：编译看左边，运行看右边</strong></p></li></ul><h2 id="1-1-多态的形式"><a href="#1-1-多态的形式" class="headerlink" title="1.1 多态的形式"></a>1.1 多态的形式</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220729090707045.png" alt="image-20220729090707045"></p><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类/实现类构造器;</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><h2 id="1-2-多态的使用场景"><a href="#1-2-多态的使用场景" class="headerlink" title="1.2 多态的使用场景"></a>1.2 多态的使用场景</h2><p>在这种情况下，只能定义不同的register方法分别接收学生，老师和管理员等。但是每个都写一个register方法，太麻烦，太琐碎了。都是重复的代码。（就是面向过程了）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220729090201250.png" alt="image-20220729090201250"></p><p>但现在有了多态之后，方法的形参就可以定义为共同的父类Person。老师类学生类都可以继承这个Person类。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220729090606815.png" alt="image-20220729090606815"></p><p><strong>要注意的是：</strong></p><ul><li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li><li>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。</li><li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li></ul><h2 id="1-3-多态的定义和前提"><a href="#1-3-多态的定义和前提" class="headerlink" title="1.3 多态的定义和前提"></a>1.3 多态的定义和前提</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><p> <strong>前提【重点】</strong></p><ol><li><p>有继承或者实现关系</p></li><li><p>方法的重写【意义体现：不重写，无意义】</p></li><li><p>父类引用指向子类对象【格式体现】</p><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="1-4-多态的运行特点"><a href="#1-4-多态的运行特点" class="headerlink" title="1.4 多态的运行特点"></a>1.4 多态的运行特点</h2><ul><li><p><strong>调用成员变量时：编译看左边，运行看左边</strong></p></li><li><p><strong>调用成员方法时：编译看左边，运行看右边</strong></p></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>()；</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有name这个属性，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，把父类name属性的值打印出来</span></span><br><span class="line">System.out.println(f.name);</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有show这个方法，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，运行的是子类中的show方法</span></span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">//理解：</span></span><br><span class="line">        <span class="comment">//Fu f = new Zi()；</span></span><br><span class="line">        <span class="comment">//现在用f去调用变量和方法的呀？是的</span></span><br><span class="line">        <span class="comment">//而f是Fu类型的，所以默认都会从Fu这个类中去找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量：在子类的对象中，会把父类的成员变量也继承下的。父：name  子：name</span></span><br><span class="line"><span class="comment">//成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的。</span></span><br></pre></td></tr></table></figure><h2 id="1-5-多态的优势和弊端"><a href="#1-5-多态的优势和弊端" class="headerlink" title="1.5 多态的优势和弊端"></a>1.5 多态的优势和弊端</h2><ul><li><strong>优势：</strong></li></ul><p>方法中，使用父类型作为参数，可以接收所有子类对象。（重要）</p><ul><li><strong>劣势：</strong></li></ul><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>｛</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃东西！&quot;</span>)</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a.eat();</span><br><span class="line">        a.catchMouse();<span class="comment">//编译报错，编译看左边，Animal没有这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220729160014599.png" alt="image-20220729160014599"></p><p>说明：正常情况下，父类是不能用子类的方法的，但是如果想用可以，强制类型转换，转换成真正的子类类型。这样可以调用子类的独有功能。</p><h2 id="1-6-引用类型转换"><a href="#1-6-引用类型转换" class="headerlink" title="1.6 引用类型转换"></a>1.6 引用类型转换</h2><h3 id="1-6-1-为什么要转型"><a href="#1-6-1-为什么要转型" class="headerlink" title="1.6.1 为什么要转型"></a>1.6.1 为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li>自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; </li><li>强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14</li></ul><p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p><h3 id="1-6-2-向上转型（自动转换）"><a href="#1-6-2-向上转型（自动转换）" class="headerlink" title="1.6.2 向上转型（自动转换）"></a>1.6.2 向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong>所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="1-6-3-向下转型（强制转换）"><a href="#1-6-3-向下转型（强制转换）" class="headerlink" title="1.6.3 向下转型（强制转换）"></a>1.6.3 向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">   <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure><h3 id="1-6-4转型的异常"><a href="#1-6-4转型的异常" class="headerlink" title="1.6.4转型的异常"></a>1.6.4转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">        d.watchHouse();        <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><h3 id="1-6-5-instanceof关键字"><a href="#1-6-5-instanceof关键字" class="headerlink" title="1.6.5 instanceof关键字"></a>1.6.5 instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line">如果变量属于该数据类型或者其子类类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量不属于该数据类型或者其子类类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><p>所以，转换前，我们最好先做一个判断，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型  </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型  </span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;       </span><br><span class="line">            c.catchMouse();        <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;       </span><br><span class="line">            d.watchHouse();       <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-6-instanceof新特性"><a href="#1-6-6-instanceof新特性" class="headerlink" title="1.6.6 instanceof新特性"></a>1.6.6 instanceof新特性</h3><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新特性</span></span><br><span class="line"><span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line">    d.lookHome();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="2-包"><a href="#2-包" class="headerlink" title="2.包"></a>2.包</h1><h2 id="2-1-包"><a href="#2-1-包" class="headerlink" title="2.1 包"></a>2.1 包</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220729093659517.png" alt="image-20220729093659517"></p><p><strong>包名的命名规范</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径名.路径名.xxx.xxx</span><br><span class="line"><span class="comment">// 例如：com.itheima.oa</span></span><br></pre></td></tr></table></figure><ul><li>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com,包名就可以定义成com.itheima.技术名称./">www.itheima.com,包名就可以定义成com.itheima.技术名称。</a></li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="2-2-使用不同包下的相同类怎么办？"><a href="#2-2-使用不同包下的相同类怎么办？" class="headerlink" title="2.2 使用不同包下的相同类怎么办？"></a>2.2 使用不同包下的相同类怎么办？</h2><p>假设demo1和demo2中都有一个Student该如何使用？</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用全类名的形式即可。</span></span><br><span class="line"><span class="comment">//全类名：包名 + 类名</span></span><br><span class="line"><span class="comment">//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference</span></span><br><span class="line">com.itheima.homework.demo1.<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.itheima.homework.demo1.Student();</span><br><span class="line">com.itheima.homework.demo2.<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.itheima.homework.demo2.Student();</span><br></pre></td></tr></table></figure><h1 id="3-权限修饰符"><a href="#3-权限修饰符" class="headerlink" title="3.权限修饰符"></a>3.权限修饰符</h1><h2 id="3-1-权限修饰符"><a href="#3-1-权限修饰符" class="headerlink" title="3.1 权限修饰符"></a>3.1 权限修饰符</h2><p>​在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。</p><ul><li><p>public：公共的，所有地方都可以访问。</p></li><li><p>protected：本类 ，本包，其他包中的子类都可以访问。</p></li><li><p>默认（没有修饰符）：本类 ，本包可以访问。</p><p>注意：默认是空着不写，不是default</p></li><li><p>private：私有的，当前类可以访问。<br> <strong>public &gt; protected &gt; 默认 &gt; private</strong></p></li></ul><h2 id="3-2-不同权限的访问能力"><a href="#3-2-不同权限的访问能力" class="headerlink" title="3.2 不同权限的访问能力"></a>3.2 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code> public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，就是默认权限</p></blockquote><h1 id="4-final关键字"><a href="#4-final关键字" class="headerlink" title="# 4.final关键字"></a># 4.final关键字</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。如果有一个方法我不想别人去改写里面内容，该怎么办呢？</p><p><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。</p><ul><li>类：被修饰的类，不能被继承。（API）</li><li>方法：被修饰的方法，不能被重写。</li><li><strong>变量：被修饰的变量，有且仅能被赋值一次。（比如圆周率3.14）</strong></li></ul><p><strong>我们一般用来修饰变量最多的，大佬才来定义类和方法。</strong></p><h3 id="4-2-1-修饰类"><a href="#4-2-1-修饰类" class="headerlink" title="4.2.1 修饰类"></a>4.2.1 修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> class 类名 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类</span></span><br></pre></td></tr></table></figure><p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p><h3 id="4-2-2-修饰方法"><a href="#4-2-2-修饰方法" class="headerlink" title="4.2.2 修饰方法"></a>4.2.2 修饰方法</h3><p>final修饰的方法，不能被重写。<br>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-修饰变量-局部变量"><a href="#4-2-3-修饰变量-局部变量" class="headerlink" title="4.2.3 修饰变量-局部变量"></a>4.2.3 修饰变量-局部变量</h3><ol><li><strong>局部变量——基本类型</strong><br>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-修饰变量-成员变量"><a href="#4-2-4-修饰变量-成员变量" class="headerlink" title="4.2.4 修饰变量-成员变量"></a>4.2.4 修饰变量-成员变量</h3><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。</p><p><strong>注意：每个构造方法中都要赋值一次！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>被final修饰的常量名称，一般都有书写规范，所有字母都大写。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java八大字符类型</title>
      <link href="/2020/05/01/java/day05-Java%E5%85%AB%E5%A4%A7%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/01/java/day05-Java%E5%85%AB%E5%A4%A7%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java八大字符类型"><a href="#Java八大字符类型" class="headerlink" title="Java八大字符类型"></a>Java八大字符类型</h1><p>*<strong>byte占一个字节范围：-128-127；</strong><br>*<strong>short占两个字节范围：-32768-32767；</strong><br>*<strong>int占4个字节范围；</strong><br>*<strong>long占8字节范围</strong><br>*<strong>float占4个字节</strong><br>*<strong>double占8字节</strong><br>*<strong>char占两字节</strong><br>*<strong>boolean占一字节只有true和false两个；</strong></p><h2 id="1-整数型"><a href="#1-整数型" class="headerlink" title="1.整数型"></a>1.整数型</h2><p>byte numb1&#x3D;15;<br>short numb2&#x3D;15454;<br>int numb3&#x3D;1546875484;<br>long numb4&#x3D;4846498881454454L;&#x2F;&#x2F;long类型要在数字后面加个L</p><h2 id="2-浮点型（小数型）精度高"><a href="#2-浮点型（小数型）精度高" class="headerlink" title="2.浮点型（小数型）精度高"></a>2.浮点型（小数型）精度高</h2><p>flout numb5&#x3D;15.1f;&#x2F;&#x2F;flout要在数字后面加个f;<br>double numb6&#x3D;45.124;</p><h2 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h2><p>char name1&#x3D;’a’;<br>char name2&#x3D;’李’;</p><h2 id="4-字符串，string不是关键字，而是类；"><a href="#4-字符串，string不是关键字，而是类；" class="headerlink" title="4.字符串，string不是关键字，而是类；"></a>4.字符串，string不是关键字，而是类；</h2><p>string name3&#x3D;”李霍霍”;</p><h2 id="5-布尔型：只有是非"><a href="#5-布尔型：只有是非" class="headerlink" title="5.布尔型：只有是非"></a>5.布尔型：只有是非</h2><p>boolean flag&#x3D;true;<br>boolean flag1&#x3D;flase;</p><h2 id="6-数组默认初始化值的规律（额外）"><a href="#6-数组默认初始化值的规律（额外）" class="headerlink" title="6.数组默认初始化值的规律（额外）"></a>6.数组默认初始化值的规律（额外）</h2><p>整数类型：默认初始值为 0</p><p>小数类型：默认初始值为 0.0</p><p>字符类型：默认初始值为 ‘&#x2F;u0000’ 空格</p><p>布尔类型：默认初始值为 false</p><p>引用数据类型：默认初始值为 null（除了这四种之外的）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 形式参数是类的问题</title>
      <link href="/2020/04/30/java/day13-java%20%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E6%98%AF%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/30/java/day13-java%20%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E6%98%AF%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>前言：我们经常会看到一个方法中里面不带参数，反而带类的情况。但是参数比较好理解，但是类可能会有点晕。所以这个例子解释了下带类的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Student s)</span>;</span><br></pre></td></tr></table></figure><p>案例：</p><p>形式参数如果是一个基本数据类型，形参的改变对实参数没有影响，需要什么数据，传递具体的值即可，形式参数如果是一个类（具体类），那么形式参数的改变直接影响实际参数！</p><p>结论：</p><p><strong>形式参数如果传递的是一个数组类型，需要传递的该数组的对象</strong><br><strong>形式参数如果传递的是具体的类，需要传递该类的具体对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="comment">//求两个数据之和的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good study&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在定义一个类StudentMethod</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentMethod</span>&#123;</span><br><span class="line">    <span class="comment">//成员方法：有一个形式参数：Student</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Student s)</span>&#123;<span class="comment">//如果形式参数一个具体类，需要传递该类对象</span></span><br><span class="line">        s.study();<span class="comment">//s变量访问study()---------&gt;需要学生具体对象才能访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArgsDemo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//需求访问Demo类中的add方法</span></span><br><span class="line">        <span class="comment">//创建该Demo类的具体对象</span></span><br><span class="line">        Demo d=<span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        <span class="type">int</span> result=d.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span>+result);</span><br><span class="line">        <span class="comment">//需求：要访问StudentMethod类中method方法</span></span><br><span class="line">        <span class="comment">//创建StudentMethod类的对象，使用对象调用method</span></span><br><span class="line">        StudentMethod sm=<span class="keyword">new</span> <span class="title class_">StudentMethod</span>();</span><br><span class="line">        <span class="comment">//需要创建一个学生对象</span></span><br><span class="line">        Student y=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//引用类型作为形参---&gt;传递的是地址值</span></span><br><span class="line">        sm.method(y);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         public void method(Student s)&#123;//将学生对象传递进来y</span></span><br><span class="line"><span class="comment">            s.study();//y.study();</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">结果是：<span class="number">30</span></span><br><span class="line">Good study</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的流程控制语句</title>
      <link href="/2020/04/01/java/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/04/01/java/day04-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-流程控制语句"><a href="#第一章-流程控制语句" class="headerlink" title="第一章 流程控制语句"></a>第一章 流程控制语句</h2><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p><h3 id="1-1-流程控制语句分类"><a href="#1-1-流程控制语句分类" class="headerlink" title="1.1 流程控制语句分类"></a>1.1 流程控制语句分类</h3><p>​顺序结构</p><p>​判断和选择结构(if, switch)</p><p>​循环结构(for, while, do…while)</p><h3 id="1-2-顺序结构"><a href="#1-2-顺序结构" class="headerlink" title="1.2 顺序结构"></a>1.2 顺序结构</h3><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><p>顺序结构执行流程图：</p><p><img src="/Users/fanshiwei/Desktop/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/Java%E5%9F%BA%E7%A1%80-%E8%B5%84%E6%96%99/day04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/%E7%AC%94%E8%AE%B0/..%5C%E7%AC%94%E8%AE%B0%5Cimg%5C1545615769372.png" alt="1545615769372"></p><h2 id="第二章-判断语句：if语句"><a href="#第二章-判断语句：if语句" class="headerlink" title="第二章 判断语句：if语句"></a>第二章 判断语句：if语句</h2><h3 id="2-1-if语句格式1"><a href="#2-1-if语句格式1" class="headerlink" title="2.1 if语句格式1"></a>2.1 if语句格式1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><p><img src="/Users/fanshiwei/Desktop/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/Java%E5%9F%BA%E7%A1%80-%E8%B5%84%E6%96%99/day04-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/%E7%AC%94%E8%AE%B0/..%5C%E7%AC%94%E8%AE%B0%5Cimg%5C1545616039363.png" alt="1545616039363"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span></span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == c) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1：老丈人选女婿"><a href="#练习1：老丈人选女婿" class="headerlink" title="练习1：老丈人选女婿"></a>练习1：老丈人选女婿</h4><p>需求：</p><p>​键盘录入女婿的酒量，如果大于2斤，老丈人给出回应，否则没有任何回应</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入女婿的酒量</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入女婿的酒量&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">wine</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//5</span></span><br><span class="line"><span class="comment">//2.对酒量进行一个判断即可</span></span><br><span class="line"><span class="keyword">if</span>(wine &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不错哟，小伙子！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2：考试奖励"><a href="#练习2：考试奖励" class="headerlink" title="练习2：考试奖励"></a>练习2：考试奖励</h4><p>需求：</p><p>​键盘录入一个整数，表示小明的考试名次，如果名次为1，小红可以当小明的女朋有了。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入一个整数，表示小明的考试名次</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入小明的名次&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对小明的考试成绩进行判断即可</span></span><br><span class="line"><span class="keyword">if</span>(rank == <span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;小红成为了小明的女朋友&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一种格式的细节："><a href="#第一种格式的细节：" class="headerlink" title="第一种格式的细节："></a>第一种格式的细节：</h4><ol><li><p>如果我们要对一个布尔类型的变量进行判断，不要写&#x3D;&#x3D;，直接把变量写在小括号中即可。</p></li><li><p>如果大括号中的语句体只有一条，那么大括号可以省略不写</p><p>如果大括号省略了，那么if只能控制距离他最近的那一条语句。</p><p><strong>建议：</strong>自己不要去写，如果别人这么写了，你要能看懂即可。</p></li></ol><h3 id="2-2-if语句格式2"><a href="#2-2-if语句格式2" class="headerlink" title="2.2 if语句格式2"></a>2.2 if语句格式2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p><img src="/..%5C%E7%AC%94%E8%AE%B0%5Cimg%5C1545616221283.png" alt="1545616221283"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值大于b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值不大于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1：吃饭"><a href="#练习1：吃饭" class="headerlink" title="练习1：吃饭"></a>练习1：吃饭</h4><p>需求：</p><p>​    键盘录入一个整数，表示身上的钱。</p><p>​            如果大于等于100块，就是网红餐厅。</p><p>​            否则，就吃经济实惠的沙县小吃。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入一个整数。表示身上的钱。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数表示身上的钱&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对钱进行判断</span></span><br><span class="line"><span class="keyword">if</span>(money &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃网红餐厅&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;福建大酒店&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2：影院选座"><a href="#练习2：影院选座" class="headerlink" title="练习2：影院选座"></a>练习2：影院选座</h4><p>需求：</p><p>​在实际开发中，电影院选座也会使用到if判断。</p><p>​假设某影院售卖了100张票，票的序号为1~100。</p><p>​其中奇数票号坐左侧，偶数票号坐右侧。</p><p>​键盘录入一个整数表示电影票的票号。</p><p>​根据不同情况，给出不同的提示：</p><p>​如果票号为奇数，那么打印坐左边。</p><p>​如果票号为偶数，那么打印坐右边。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入票号</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入票号&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(ticket &gt;= <span class="number">1</span> &amp;&amp; ticket &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//合法</span></span><br><span class="line">    <span class="comment">//2.对票号进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (ticket % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;坐右边&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;坐左边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//票号不合法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;票号不合法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-if语句格式3"><a href="#2-3-if语句格式3" class="headerlink" title="2.3 if语句格式3"></a>2.3 if语句格式3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><p><img src="/..%5C%E7%AC%94%E8%AE%B0%5Cimg%5C1545616667104.png" alt="1545616667104"></p><h4 id="练习1：考试奖励"><a href="#练习1：考试奖励" class="headerlink" title="练习1：考试奖励"></a>练习1：考试奖励</h4><p>需求：</p><p>​小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，</p><p>假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。</p><p>分析：</p><p>​①小明的考试成绩未知，可以使用键盘录入的方式获取值</p><p>​②由于奖励种类较多，属于多种判断，采用if…else…if格式实现</p><p>​③为每种判断设置对应的条件</p><p>​④为每种判断设置对应的奖励</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//95~100 自行车一辆</span></span><br><span class="line"><span class="comment">//90~94   游乐场玩一天</span></span><br><span class="line"><span class="comment">//80 ~ 89 变形金刚一个</span></span><br><span class="line"><span class="comment">//80 以下  胖揍一顿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.键盘录入一个值表示小明的分数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入小明的成绩&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对分数的有效性进行判断</span></span><br><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//有效的分数</span></span><br><span class="line">    <span class="comment">//3.对小明的分数进行判断，不同情况执行不同的代码</span></span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">95</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;送自行车一辆&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">94</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游乐场玩一天&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">89</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;变形金刚一个&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;胖揍一顿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//无效的分数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;分数不合法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-switch语句"><a href="#第三章-switch语句" class="headerlink" title="第三章 switch语句"></a>第三章 switch语句</h2><h3 id="3-1-格式"><a href="#3-1-格式" class="headerlink" title="3.1 格式"></a>3.1 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句体n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-执行流程："><a href="#3-2-执行流程：" class="headerlink" title="3.2 执行流程："></a>3.2 <strong>执行流程：</strong></h3><ul><li>首先计算出表达式的值 </li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 </li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul><h4 id="练习：运动计划"><a href="#练习：运动计划" class="headerlink" title="练习：运动计划"></a>练习：运动计划</h4><ul><li><p>需求：键盘录入星期数，显示今天的减肥活动。</p><p>周一：跑步  </p><p>周二：游泳  </p><p>周三：慢走  </p><p>周四：动感单车</p><p>周五：拳击  </p><p>周六：爬山  </p><p>周日：好好吃一顿</p></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a01switch选择语句;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录入一个整数表示星期</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数表示星期&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.书写一个switch语句去跟week进行匹配</span></span><br><span class="line">        <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入错误，没有这个星期&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-switch的扩展知识："><a href="#3-3-switch的扩展知识：" class="headerlink" title="3.3 switch的扩展知识："></a>3.3 switch的扩展知识：</h3><ul><li><p>default的位置和省略情况</p><p>default可以放在任意位置，也可以省略</p></li><li><p>case穿透</p><p>不写break会引发case穿透现象</p></li><li><p>switch在JDK12的新特性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch和if第三种格式各自的使用场景</li></ul><p>当我们需要对一个范围进行判断的时候，用if的第三种格式</p><p>当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句</p><p>比如：</p><p>​小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。</p><p>​如果是星期，月份，客服电话中0~9的功能选择就可以用switch</p><h4 id="练习：休息日和工作日"><a href="#练习：休息日和工作日" class="headerlink" title="练习：休息日和工作日"></a>练习：休息日和工作日</h4><p>需求：键盘录入星期数，输出工作日、休息日。</p><p>(1-5) 工作日，(6-7)休息日。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入星期数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入星期&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//3</span></span><br><span class="line"><span class="comment">//2.利用switch进行匹配</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">利用<span class="keyword">case</span>穿透简化代码</span><br><span class="line"><span class="keyword">switch</span> (week)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;工作日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;休息日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line">利用JDK12简化代码书写</span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; System.out.println(<span class="string">&quot;工作日&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; System.out.println(<span class="string">&quot;休息日&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-循环结构"><a href="#第四章-循环结构" class="headerlink" title="第四章 循环结构"></a>第四章 循环结构</h2><h3 id="4-1-for循环结构（掌握）"><a href="#4-1-for循环结构（掌握）" class="headerlink" title="4.1 for循环结构（掌握）"></a>4.1 for循环结构（掌握）</h3><p>​循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 </p><h4 id="4-1-1-for循环格式："><a href="#4-1-1-for循环格式：" class="headerlink" title="4.1.1 for循环格式："></a>4.1.1 for循环格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>格式解释：</strong></p><ul><li>初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul><p><strong>执行流程：</strong></p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p>​             如果是false，循环结束</p><p>​             如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p><p><strong>for循环书写技巧：</strong></p><ul><li>确定循环的开始条件</li><li>确定循环的结束条件</li><li>确定循环要重复执行的代码</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.确定循环的开始条件</span></span><br><span class="line"><span class="comment">//2.确定循环的结束条件</span></span><br><span class="line"><span class="comment">//3.确定要重复执行的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：打印5次HelloWorld</span></span><br><span class="line"><span class="comment">//开始条件：1</span></span><br><span class="line"><span class="comment">//结束条件：5</span></span><br><span class="line"><span class="comment">//重复代码：打印语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for循环练习-输出数据"><a href="#for循环练习-输出数据" class="headerlink" title="for循环练习-输出数据"></a>for循环练习-输出数据</h5><ul><li>需求：在控制台输出1-5和5-1的数据 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：输出数据1-5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//需求：输出数据5-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for循环练习-求和"><a href="#for循环练习-求和" class="headerlink" title="for循环练习-求和"></a>for循环练习-求和</h5><ul><li>需求：求1-5之间的数据和，并把求和结果在控制台输出  </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从1开始到5结束的数据，使用循环结构完成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//将反复进行的事情写入循环结构内部</span></span><br><span class="line">             <span class="comment">// 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中</span></span><br><span class="line">sum = sum + i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum += i;sum = sum + i;</span></span><br><span class="line"><span class="comment">第一次：sum = sum + i = 0 + 1 = 1;</span></span><br><span class="line"><span class="comment">第二次：sum = sum + i = 1 + 2 = 3;</span></span><br><span class="line"><span class="comment">第三次：sum = sum + i = 3 + 3 = 6;</span></span><br><span class="line"><span class="comment">第四次：sum = sum + i = 6 + 4 = 10;</span></span><br><span class="line"><span class="comment">第五次：sum = sum + i = 10 + 5 = 15;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-5之间的数据和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本题要点：<ul><li>今后遇到的需求中，如果带有求和二字，请立即联想到求和变量</li><li>求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的</li></ul></li></ul><h5 id="for循环练习-求偶数和"><a href="#for循环练习-求偶数和" class="headerlink" title="for循环练习-求偶数和"></a>for循环练习-求偶数和</h5><ul><li>需求：求1-100之间的偶数和，并把求和结果在控制台输出 }</li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//sum += i；</span></span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的偶数和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for循环练习-统计次数"><a href="#for循环练习-统计次数" class="headerlink" title="for循环练习-统计次数"></a>for循环练习-统计次数</h5><p>需求：</p><p>​  键盘录入两个数字，表示一个范围。</p><p>​           统计这个范围中。</p><p>​           既能被3整除，又能被5整除数字有多少个？</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-while循环"><a href="#4-2-while循环" class="headerlink" title="4.2 while循环"></a>4.2 while循环</h3><h4 id="4-2-1-格式："><a href="#4-2-1-格式：" class="headerlink" title="4.2.1 格式："></a>4.2.1 格式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(条件判断语句)&#123;</span><br><span class="line">循环体;</span><br><span class="line">条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习1：打印5次HelloWorld"><a href="#练习1：打印5次HelloWorld" class="headerlink" title="练习1：打印5次HelloWorld"></a>练习1：打印5次HelloWorld</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h5 id="练习2：珠穆朗玛峰"><a href="#练习2：珠穆朗玛峰" class="headerlink" title="练习2：珠穆朗玛峰"></a>练习2：珠穆朗玛峰</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个变量表示珠穆朗玛峰的高度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">8844430</span>;</span><br><span class="line"><span class="comment">//2.定义一个变量表示纸张的厚度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个计数器（变量），用来统计折叠的次数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.循环折叠纸张</span></span><br><span class="line"><span class="comment">//只有纸张的厚度 &lt; 穆朗玛峰的高度 循环才继续，否则循环就停止</span></span><br><span class="line"><span class="comment">//坑：只有判断为真，循环才会继续</span></span><br><span class="line"><span class="keyword">while</span>(paper &lt; height)&#123;</span><br><span class="line">    <span class="comment">//折叠纸张</span></span><br><span class="line">    paper = paper * <span class="number">2</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.打印一下纸张的厚度</span></span><br><span class="line">System.out.println(count);<span class="comment">//27</span></span><br></pre></td></tr></table></figure><h3 id="4-3-do…while循环"><a href="#4-3-do…while循环" class="headerlink" title="4.3 do…while循环"></a>4.3 do…while循环</h3><p>本知识点了解即可</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure><p>特点：</p><p>​先执行，再判断。</p><h3 id="4-4-三种格式的区别："><a href="#4-4-三种格式的区别：" class="headerlink" title="4.4 三种格式的区别："></a>4.4 三种格式的区别：</h3><p>​<strong>for和while循环，是先判断，再执行。</strong></p><p>​<strong>do…while是先执行，再判断。</strong></p><p>​<strong>当知道循环次数或者循环范围的时候，用for循环。</strong></p><p>​<strong>当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装和static关键字</title>
      <link href="/2020/03/30/java/day12-static/"/>
      <url>/2020/03/30/java/day12-static/</url>
      
        <content type="html"><![CDATA[<h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h1><h2 id="1-1封装的步骤"><a href="#1-1封装的步骤" class="headerlink" title="1.1封装的步骤"></a>1.1封装的步骤</h2><p>1.使用 <code>private</code> 关键字来修饰成员变量。</p><p>–pravate String name;</p><p>2.使用<code>public</code>修饰getter和setter方法。</p><p>–修饰getter和settter方法</p><h1 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h1><h2 id="2-1静态变量"><a href="#2-1静态变量" class="headerlink" title="2.1静态变量"></a>2.1静态变量</h2><p>我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。</p><p>通俗说法：比如一个班级，学生的姓名年龄都是不一样的。所以都是各自定义的，但是如果是老师呢，每个学生都要赋值一个老师。是不是太麻烦了呢，是的</p><p>所以我们要定义一个公共的老师，让大家都是这个老师，张三是的，李四也是。所以就不需要都定义一遍，只要在类中声明就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728162258240.png" alt="image-20220728162258240"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(Student.schoolName); </span><br><span class="line">    Student.schoolName = <span class="string">&quot;王老师&quot;</span>;</span><br><span class="line">    System.out.println(Student.schoolName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2实例变量及其访问"><a href="#2-2实例变量及其访问" class="headerlink" title="2.2实例变量及其访问"></a>2.2实例变量及其访问</h2><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前我们写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。   </p><h2 id="2-3工具类"><a href="#2-3工具类" class="headerlink" title="2.3工具类"></a>2.3工具类</h2><ul><li>被static修饰的成员变量，叫做静态变量</li><li>被static修饰的成员方法，叫做静态方法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728162913918.png" alt="image-20220728162913918"></p><p>目前通常有三种类：</p><p><strong>javabean类：</strong>用来描述一类事物的类。比如，Student，Teacher，Dog等。</p><p><strong>测试类：</strong>用来检查其他类是否书写正确，带有main方法的类，是程序的入口。</p><p><strong>工具类：</strong>不是用来描述一类事物的，而是帮我们做一些事情的类。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728163244647.png" alt="image-20220728163244647"></p><p><strong>工具类注意：</strong></p><p><strong>—1.类名见名知意：</strong>比如加个Util代表工具类，如ArrUtil，</p><p><strong>—2.私有化构造方法：</strong> 构造方法一旦私有，外界就不能创建这个类的 对象。（因为工具类是没有意义的，所以创建多个也没有用，用不到！）</p><p><strong>—3.方法定义为静态；</strong>方便调用 </p><h2 id="2-4静态方法"><a href="#2-4静态方法" class="headerlink" title="2.4静态方法"></a>2.4静态方法</h2><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728170454175.png" alt="image-20220728170454175"></p><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2-5小结"><a href="#2-5小结" class="headerlink" title="2.5小结"></a>2.5小结</h2><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法<strong>直接通过类名</strong>访问即可，完全没有必要用对象去访问。<strong>（Student.study();）</strong></p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728204715657.png" alt="image-20220728204715657"></p><h1 id="3-重新认识main方法"><a href="#3-重新认识main方法" class="headerlink" title="3.重新认识main方法"></a>3.重新认识main方法</h1><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728205424784.png" alt="image-20220728205424784"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串和集合</title>
      <link href="/2020/03/27/java/day11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2020/03/27/java/day11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><h3 id="1-1API概述"><a href="#1-1API概述" class="headerlink" title="1.1API概述"></a>1.1API概述</h3><ul><li><p>什么是API</p><p>API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>简单理解</p><p>API就是别人写好的东西，我们不需要自己编写，直接使用即可。</p></li><li><p>Java API</p><p>指的就是JDK中提供的各种功能的JAVA类。</p></li></ul><p> <img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728074156869.png" alt="image-20220728074156869"></p><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述"><a href="#2-1String类概述" class="headerlink" title="2.1String类概述"></a>2.1String类概述</h3><p>​String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点"><a href="#2-2String类的特点" class="headerlink" title="2.2String类的特点"></a>2.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改（如果要变，可以变成数组，拆分每个字符，然后再重组，麻烦。）</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法"><a href="#2-3String类的构造方法" class="headerlink" title="2.3String类的构造方法"></a>2.3String类的构造方法</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728081329663.png" alt="image-20220728081329663"></p><p>直接赋值用的是最多的。其次就是字符数组和字节数组（3、4）</p><h3 id="2-4创建字符串对象两种方式的区别"><a href="#2-4创建字符串对象两种方式的区别" class="headerlink" title="2.4创建字符串对象两种方式的区别"></a>2.4创建字符串对象两种方式的区别</h3><ul><li><p>通过构造方法创建</p><p>通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p>以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ul><h3 id="2-5字符串的比较"><a href="#2-5字符串的比较" class="headerlink" title="2.5字符串的比较"></a>2.5字符串的比较</h3><h4 id="2-5-1-x3D-x3D-号的作用"><a href="#2-5-1-x3D-x3D-号的作用" class="headerlink" title="2.5.1&#x3D;&#x3D;号的作用"></a>2.5.1&#x3D;&#x3D;号的作用</h4><ul><li>比较基本数据类型：比较的是具体的数据值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728082227425.png" alt="image-20220728082227425"></p><p>字符串的比较</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728082409378.png" alt="image-20220728082409378"></p><h4 id="2-5-2equals方法的作用"><a href="#2-5-2equals方法的作用" class="headerlink" title="2.5.2equals方法的作用"></a>2.5.2equals方法的作用</h4><ul><li><p>方法介绍（equals）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(String s)</span>     比较两个字符串内容是否相同、区分大小写</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>忽视大小写的比较方法（equalsIgnore）</p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728083758825.png" alt="image-20220728083758825"></p></li></ul><p>只要想比较字符串的内容，就必要用String里面的方法。（根据这个结论做2.6）</p><h3 id="2-6用户登录案例"><a href="#2-6用户登录案例" class="headerlink" title="2.6用户登录案例"></a>2.6用户登录案例</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示。</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span>登录案例 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义两个变量用来记录正确的用户名和密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightUsername</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPassword</span> <span class="operator">=</span> <span class="string">&quot;1234qwer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.键盘录入用户名和密码</span></span><br><span class="line">        <span class="comment">//ctrl + alt + T 选择包裹方式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//0 1 2</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.判断比较</span></span><br><span class="line">            <span class="keyword">if</span> (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="comment">//如果正确，循环结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最后一次机会</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;账户&quot;</span> + username + <span class="string">&quot;被锁定，请联系黑马程序员官方小姐姐：XXXXXXX&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//不是最后一次机会</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;用户名或密码错误，登录失败,还剩下&quot;</span> + (<span class="number">2</span> - i) + <span class="string">&quot;次机会&quot;</span>);<span class="comment">//2 1 0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道循环用次数用for，不知道用while（技巧）</p><h3 id="2-7String常用API"><a href="#2-7String常用API" class="headerlink" title="2.7String常用API"></a>2.7String常用API</h3><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728101937447.png" alt="image-20220728101937447"></p><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728142815968.png" alt="image-20220728142815968"></p><h2 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3.ArrayList"></a>3.ArrayList</h2><h3 id="集合和数组的优势对比："><a href="#集合和数组的优势对比：" class="headerlink" title="集合和数组的优势对比："></a>集合和数组的优势对比：</h3><ol><li>长度可变</li><li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li></ol><h3 id="3-1-ArrayList类概述"><a href="#3-1-ArrayList类概述" class="headerlink" title="3.1 ArrayList类概述"></a>3.1 ArrayList类概述</h3><ul><li><p>什么是集合</p><p>​提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>​长度可以变化，只能存储引用数据类型。</p></li><li><p>泛型的使用</p><p>​用于约束集合中存储元素的数据类型</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2Arraylist成员方法"><a href="#3-2Arraylist成员方法" class="headerlink" title="3.2Arraylist成员方法"></a>3.2Arraylist成员方法</h2><p><img src="https://cdn.jsdelivr.net/gh/FanMiLi666/picgo/img/image-20220728143321130.png" alt="image-20220728143321130"></p><p> 根据上图所编写的测试例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个集合</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加一个元素</span></span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.删除一个元素</span></span><br><span class="line">list.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1删除索引元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.修改元素</span></span><br><span class="line">list.set(<span class="number">0</span>,<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.查询元素</span></span><br><span class="line">list.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//i:索引</span></span><br><span class="line">    <span class="comment">//list.get(i) 元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(s);</span><br></pre></td></tr></table></figure><p><strong>注意：list的遍历和其他还不一样，list的遍历都是size。其他的都是length。而且size还是一个方法。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的运算符</title>
      <link href="/2020/03/01/java/day03-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/03/01/java/day03-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运算符和表达式"><a href="#1-运算符和表达式" class="headerlink" title="1.运算符和表达式"></a>1.运算符和表达式</h1><h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><p>​就是对常量或者变量进行操作的符号。</p><p>​比如： +  -  *  &#x2F; </p><h3 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h3><p>​用运算符把常量或者变量连接起来的，符合Java语法的式子就是表达式。</p><p>​比如：a + b 这个整体就是表达式。</p><p>​而其中+是算术运算符的一种，所以这个表达式也称之为算术表达式。</p><h1 id="2-算术运算符"><a href="#2-算术运算符" class="headerlink" title="2.算术运算符"></a>2.算术运算符</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure><p>运算特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * :跟小学数学中一模一样没有任何区别.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/：</span><br><span class="line"><span class="number">1.</span>整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。</span><br><span class="line"><span class="number">2.</span>小数直接参与运算，得到的结果有可能是不精确的。</span><br><span class="line">案例：</span><br><span class="line">System.out.println( <span class="number">10</span> / <span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">3</span>);<span class="comment">//3.3333333333333335</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%：取模、取余。</span><br><span class="line">   他做的也是除法运算，只不过获取的是余数而已。</span><br><span class="line">案例：</span><br><span class="line">System.out.println(<span class="number">10</span> % <span class="number">2</span>);<span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="number">10</span> % <span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">应用场景：</span><br><span class="line"><span class="comment">//可以利用取模来判断一个数是奇数还是偶数</span></span><br><span class="line">System.out.println(<span class="number">15</span> % <span class="number">2</span>);<span class="comment">//1  奇数</span></span><br></pre></td></tr></table></figure><h3 id="练习：数值拆分"><a href="#练习：数值拆分" class="headerlink" title="练习：数值拆分"></a>练习：数值拆分</h3><p>需求：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.键盘录入一个三位数</span></span><br><span class="line"><span class="comment">//导包 --- 创建对象 --- 接收数据</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个三位数&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取这个三位数的个位、十位、百位并打印出来</span></span><br><span class="line"><span class="comment">//公式：</span></span><br><span class="line"><span class="comment">//针对于任意的一个数而言</span></span><br><span class="line"><span class="comment">//个位： 数字 % 10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> number % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//十位： 数字 / 10 % 10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tens</span> <span class="operator">=</span> number / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//百位： 数字 / 100 % 10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hundreds</span> <span class="operator">=</span> number / <span class="number">100</span>  % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">System.out.println(ones);</span><br><span class="line">System.out.println(tens);</span><br><span class="line">System.out.println(hundreds);</span><br></pre></td></tr></table></figure><p>公式：</p><p>​获取任意一个数上每一位数。</p><p>个位：数字 % 10</p><p>十位：数字 &#x2F; 10 % 10</p><p>百位：数字 &#x2F; 100 % 10</p><p>千位：数字 &#x2F; 1000 % 10</p><p>。。。以此类推。。。</p><h1 id="3-隐式转换"><a href="#3-隐式转换" class="headerlink" title="3.隐式转换"></a>3.隐式转换</h1><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>​也叫自动类型提升。</p><p>​就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。</p><h3 id="简单记忆："><a href="#简单记忆：" class="headerlink" title="简单记忆："></a>简单记忆：</h3><p>​就是小的给大的，可以直接给。</p><h3 id="两种提升规则："><a href="#两种提升规则：" class="headerlink" title="两种提升规则："></a>两种提升规则：</h3><ul><li>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。</li><li>byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。</li></ul><h3 id="取值范围从小到大的关系："><a href="#取值范围从小到大的关系：" class="headerlink" title="取值范围从小到大的关系："></a>取值范围从小到大的关系：</h3><p>​byte short int long float double</p><h1 id="4-隐式转换的练习"><a href="#4-隐式转换的练习" class="headerlink" title="4.隐式转换的练习"></a>4.隐式转换的练习</h1><p>请看下面案例是否有误，如果有问题，请说出原因，如果没有问题，请说出运算过程和运算结果</p><h3 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//10.0</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>​10是整数，整数默认是int类型的。</p><p>​而在取值范围的顺序中：byte short int long float double</p><p>​在赋值的时候把一个int类型的赋值给了一个double类型的。把一个小的赋值给一个大的是可以直接给的。</p><h3 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b;<span class="comment">//可以成功赋值</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>​因为byte的取值范围是小的，int的取值范围是大的，在底层进行了隐式转换，不需要我们额外写代码单独实现，是可以直接赋值。</p><h3 id="案例三："><a href="#案例三：" class="headerlink" title="案例三："></a>案例三：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20L</span>;</span><br><span class="line">??? result = i + n;</span><br><span class="line">问变量result是什么类型的？</span><br></pre></td></tr></table></figure><p>解释：</p><p>​变量i是int类型的，变量n是long类型的。</p><p>​而在取值范围的顺序中：byte short int long float double</p><p>​变量i里面的值会自动提升为long类型的，最终的结果其实就是两个long相加，那么最终的result是long类型的。</p><h3 id="案例四："><a href="#案例四：" class="headerlink" title="案例四："></a>案例四：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line">??? result = i + n + d;</span><br><span class="line">问变量result是什么类型的？</span><br></pre></td></tr></table></figure><p>解释：</p><p>​变量i是int类型，变量n是long类型，变量d是double类型。</p><p>​而在取值范围的顺序中：byte short int long float double</p><p>​所以变量i和变量n里面的值在参与运算的时候，都会进行类型提升，变成double。</p><p>​最终其实就是三个double进行相加，那么最终的结果就是double类型的。</p><h3 id="案例五："><a href="#案例五：" class="headerlink" title="案例五："></a>案例五：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">??? result = b1 + b2;<span class="comment">//int</span></span><br><span class="line">问变量result是什么类型的？</span><br></pre></td></tr></table></figure><p>解释：</p><p>​因为b1和b2都是byte类型的。所以在参与计算的时候，变量b1和变量b2里面的值都会自动提升为int类型的。最终其实就是两个int类型的相加，最终结果也是int类型的。</p><h3 id="案例六："><a href="#案例六：" class="headerlink" title="案例六："></a>案例六：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line">??? result = b + s + n;</span><br><span class="line">问变量result是什么类型的？<span class="type">long</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>​变量b是byte类型的，变量s是short类型的，变量n是long类型的。</p><p>​byte，short，char类型的变量在参与运算的时候，变量里面的值会直接先提升为int。</p><p>第一步：变量b和变量s里面的值会先提升为int参与运算。</p><p>​int + int + long</p><p>第二步：而long类型的取值范围是大于int的取值范围的。</p><p>​所以变量b和变量s里面的值会再次提升为long。</p><p>​long + long + long。</p><p>所以最终结果是long类型的。</p><h1 id="5-强制转换"><a href="#5-强制转换" class="headerlink" title="5.强制转换"></a>5.强制转换</h1><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>​如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。</p><p>​如果一定要这么干，就需要加入强制转换。</p><h3 id="书写格式："><a href="#书写格式：" class="headerlink" title="书写格式："></a>书写格式：</h3><p>​目标数据类型 变量名 &#x3D; （目标数据类型）被强转的数据；</p><p>简单理解：</p><p>​要转成什么类型的，那么就在小括号中写什么类型就可以了。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12.3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a;</span><br><span class="line">        System.out.println(b);<span class="comment">//12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><p>​强制转换有可能会导致数据发生错误。（数据的精度丢失）</p><h1 id="6-字符串的-操作"><a href="#6-字符串的-操作" class="headerlink" title="6.字符串的+操作"></a>6.字符串的+操作</h1><h3 id="核心技巧："><a href="#核心技巧：" class="headerlink" title="核心技巧："></a>核心技巧：</h3><ul><li>当+操作中出现字符串时，此时就是字符串的连接符，会将前后的数据进行拼接，并产生一个新的字符串。</li><li>当连续进行+操作时，从左到右逐个执行的。</li></ul><h1 id="7-字符串相加的练习："><a href="#7-字符串相加的练习：" class="headerlink" title="7.字符串相加的练习："></a>7.字符串相加的练习：</h1><p>案例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：”1abc1”</p><p>解释：</p><p>​第一步： 1 + “abc”。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串”1abc”</p><p>​第二步：  “1abc” + 1。这个过程中，有字符串参与的，所以做的也是拼接操作，产生一个新的字符串”1abc1”</p><p>案例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：“3abc21”</p><p>解释：</p><p>​第一步：1 + 2 。在这个过程中，没有字符串参与的，所以做的是加法运算，结果为3。</p><p>​第二步：3 + “abc”。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串”3abc”。</p><p>​第三步：”3abc” + 2。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串”3abc2”。</p><p>​第四步：”3abc2” + 1。在这个过程中，有字符串参与的，所以做的是拼接操作，产生一个新的字符串“3abc21”</p><p>案例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;黑默丁格&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;我的名字是&quot;</span> + name);</span><br></pre></td></tr></table></figure><p>结果： 我的名字是黑默丁格</p><p>解释：当字符串跟变量相加的时候，实际上是跟变量里面的值进行拼接。</p><h1 id="8-字符的-操作"><a href="#8-字符的-操作" class="headerlink" title="8.字符的+操作"></a>8.字符的+操作</h1><h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><p>​当+操作中出现了字符，会拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算。</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c + <span class="number">0</span>;</span><br><span class="line">System.out.println(result);<span class="comment">//97</span></span><br></pre></td></tr></table></figure><p>ASCII码表中：</p><p>​‘a’   —–    97</p><p>​‘A’   —–    65</p><h1 id="9-算术运算符的总结"><a href="#9-算术运算符的总结" class="headerlink" title="9.算术运算符的总结"></a>9.算术运算符的总结</h1><p>分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / %  这些操作跟小学数学几乎是一模一样的。</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>&#x2F; 和 % 的区别：他们两个都是做除法运算，&#x2F;取结果的商。% 取结果的余数。</li><li>整数操作只能得到整数，如果想要得到小数，必须有浮点数参与运算。</li></ul><p>算术运算符的高级用法：</p><p>是以+为例进行的讲解，其余减法，乘法，除法的运算规则也是一样的。</p><p>特例：字符串只有+操作，没有其他操作。</p><h1 id="10-自增自减运算符"><a href="#10-自增自减运算符" class="headerlink" title="10.自增自减运算符"></a>10.自增自减运算符</h1><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++  自增运算符</span><br><span class="line">--  自减运算符</span><br></pre></td></tr></table></figure><p>++：就是把变量里面的值+1</p><p>–：就是把变量里面的值-1</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><ul><li>放在变量的前面，我们叫做先++。 比如：++a</li><li>放在变量的后面，我们叫做后++。 比如：a++</li></ul><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>​不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。</p><h3 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//++</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a++;<span class="comment">//就是让变量a里面的值 + 1</span></span><br><span class="line">System.out.println(a);<span class="comment">//11</span></span><br><span class="line">++a;<span class="comment">//就是让变量a里面的值 + 1</span></span><br><span class="line">System.out.println(a);<span class="comment">//12</span></span><br></pre></td></tr></table></figure><h3 id="自增自减运算符的应用场景："><a href="#自增自减运算符的应用场景：" class="headerlink" title="自增自减运算符的应用场景："></a>自增自减运算符的应用场景：</h3><p>某些情况下，变量需要进行加1或者减1的时候使用。</p><p>比如：过生日多一岁，就用到了自增运算符。</p><p>比如：购物商场中，选择商品数量，也用到了自增或者自减运算符。</p><p>比如：统计很多数据中，有多少个数据满足要求，也用到了自增运算符。</p><h1 id="11-赋值运算符"><a href="#11-赋值运算符" class="headerlink" title="11.赋值运算符"></a>11.赋值运算符</h1><p>最为常用的：&#x3D;</p><p>运算过程：就是把等号右边的结果赋值给左边的变量</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.最为简单的赋值运算符用法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//就是把10赋值给变量a</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.如果等号右边需要进行计算。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;<span class="comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.特殊的用法</span></span><br><span class="line">        a = a + <span class="number">10</span>;<span class="comment">//先计算等号右边的，把计算的结果赋值给左边的变量</span></span><br><span class="line">        System.out.println(a);<span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-扩展赋值运算符"><a href="#12-扩展赋值运算符" class="headerlink" title="12.扩展赋值运算符"></a>12.扩展赋值运算符</h1><h3 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h3><p>​+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p><h3 id="运算规则："><a href="#运算规则：" class="headerlink" title="运算规则："></a>运算规则：</h3><p>​就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。</p><h3 id="案例：-2"><a href="#案例：-2" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//扩展赋值运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        a += b;<span class="comment">//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响</span></span><br><span class="line">        <span class="comment">// 相当于 a = a + b;</span></span><br><span class="line">        System.out.println(a);<span class="comment">//30</span></span><br><span class="line">        System.out.println(b);<span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><p>​扩展的赋值运算符中隐层还包含了一个强制转换。</p><p>以+&#x3D;为例。</p><p>a +&#x3D; b ;实际上相当于 a &#x3D; (byte)(a + b);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//a += b;</span></span><br><span class="line">        a = (<span class="type">byte</span>)(a + b);</span><br><span class="line">        System.out.println(a);<span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-关系运算符"><a href="#13-关系运算符" class="headerlink" title="13.关系运算符"></a>13.关系运算符</h1><p>又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。</p><h3 id="分类：-2"><a href="#分类：-2" class="headerlink" title="分类："></a>分类：</h3><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false</td></tr><tr><td>!&#x3D;</td><td>就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false</td></tr><tr><td>&gt;</td><td>就是判断左边是否大于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&gt;&#x3D;</td><td>就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&lt;</td><td>就是判断左边是否小于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&lt;&#x3D;</td><td>就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false</td></tr></tbody></table><h3 id="注意点：-2"><a href="#注意点：-2" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>关系运算符最终的结果一定是布尔类型的。要么是true，要么是false</li><li>在写&#x3D;&#x3D;的时候，千万不要写成&#x3D;</li></ul><h1 id="14-逻辑运算符"><a href="#14-逻辑运算符" class="headerlink" title="14.逻辑运算符"></a>14.逻辑运算符</h1><h3 id="amp-和-的使用："><a href="#amp-和-的使用：" class="headerlink" title="&amp; 和 | 的使用："></a>&amp; 和 | 的使用：</h3><p>&amp;：逻辑与（而且）</p><p>​两边都为真，结果才是真，只要有一个为假，那么结果就是假。</p><p>|：逻辑或（或者）</p><p>​两边都为假，结果才是假，只要有一个为真，那么结果就是真。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;  //两边都是真，结果才是真。</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp; <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> &amp; <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> &amp; <span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。</span></span><br><span class="line">System.out.println(<span class="literal">true</span> | <span class="literal">true</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> | <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> | <span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> | <span class="literal">true</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>​根据固定的场景，来选择使用&amp;还是使用|</p><ul><li><p>用户登录。</p><p>用户名输入正确  &amp; 密码输入正确</p><p>因为只有用户名和密码同时都正确了，那么才能成功登录，只要有一个失败了都不行。</p><p>使用技巧：</p><p>​当我们需要同时满足左边和右边两种情况时，可以使用且</p></li><li><p>丈母娘选女婿</p><p>丈母娘：女婿啊，你要么买个房子，要么买辆车。就可以把我的小棉袄穿走了。</p><p>买个房子 | 买辆车</p><p>两个条件中，只要满足其中一个，就可以穿走小棉袄了。</p><p>使用技巧：</p><p>​当两种条件只要满足其中一个的时候，可以使用或</p></li></ul><h3 id="（异或）的使用："><a href="#（异或）的使用：" class="headerlink" title="^（异或）的使用："></a>^（异或）的使用：</h3><p>​在以后用的不多，了解一下即可。</p><p>计算规则：如果两边相同，结果为false，如果两边不同，结果为true</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//^   //左右不相同，结果才是true，左右相同结果就是false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">false</span>);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">true</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="（取反）的使用："><a href="#（取反）的使用：" class="headerlink" title="!（取反）的使用："></a>!（取反）的使用：</h3><p>​是取反，也叫做非。</p><p>计算规则：false取反就是true，true取反就是false</p><p>温馨提示：<strong>取反最多只用一个。</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(!<span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(!<span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(!!<span class="literal">false</span>);<span class="comment">//注意点：取反最多只用一个。</span></span><br></pre></td></tr></table></figure><h1 id="15-短路逻辑运算符"><a href="#15-短路逻辑运算符" class="headerlink" title="15.短路逻辑运算符"></a>15.短路逻辑运算符</h1><p>分类：  &amp;&amp;   ||</p><h3 id="amp-amp-："><a href="#amp-amp-：" class="headerlink" title="&amp;&amp;："></a>&amp;&amp;：</h3><p>​运算结果跟&amp;是一模一样的，只不过具有短路效果。</p><h3 id="："><a href="#：" class="headerlink" title="||："></a>||：</h3><p>​运算结果跟|是一模一样的。只不过具有短路效果。</p><h3 id="逻辑核心："><a href="#逻辑核心：" class="headerlink" title="逻辑核心："></a>逻辑核心：</h3><p>​当左边不能确定整个表达式的结果，右边才会执行。</p><p>​当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><ul><li><p>用户登录案例</p><p>用户名正确  &amp; 密码正确</p><p>如果使用一个&amp;，不管用户名是否正确都会去验证密码。</p></li></ul><p>思考：</p><p>​如果用户名输入正确了，那么我们再判断密码是否正确，是符合业务逻辑的。</p><p>​但是如果用户名输入错误了，那么现在还有必要去比较密码吗？没有不要了。</p><p>​如果使用一个&amp;，那么左边和右边不管什么情况下，都会执行。</p><p>​用户名正确  &amp;&amp;  密码正确</p><p>​如果用户名输入正确了，那么才会验证密码是否输入正确。</p><p>​如果用户名输入错误了，那么就不会再去验证密码是否正确，最终的结果直接为false。从而提高了程序运行的效率。</p><ul><li><p>丈母娘选女婿</p><p>有房 |  有车</p><p>首先先看看有没有房，发现有，然后再去看看有没有车。</p></li></ul><p>思考：</p><p>​既然都有房子，干嘛还要去看车呢？多此一举。</p><p>​有房 ||  有车</p><p>​首先先看看有没有房，如果有，那么右边就不执行了。最终的结果直接为true。</p><p>​如果没有房子，才会去看右边有没有车。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​&amp;&amp; 和 &amp; 、||和|的运行结果都是一模一样的。</p><p>​但是短路逻辑运算符可以提高程序的运行效率。</p><h3 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h3><p>​最为常用： &amp;&amp;   ||   ！</p><h1 id="16-三元运算符"><a href="#16-三元运算符" class="headerlink" title="16.三元运算符"></a>16.三元运算符</h1><p>又叫做：三元表达式或者问号冒号表达式。</p><h3 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h3><p>​关系表达式 ？ 表达式1 ：表达式2 ；</p><h3 id="计算规则："><a href="#计算规则：" class="headerlink" title="计算规则："></a>计算规则：</h3><ul><li>计算关系表达式的值。</li><li>如果关系表达式的值为真，那么执行表达式1。</li><li>如果关系表达式的值为假，那么执行表达式2。</li></ul><h3 id="注意点：-3"><a href="#注意点：-3" class="headerlink" title="注意点："></a>注意点：</h3><p>​三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</p><h3 id="案例：-3"><a href="#案例：-3" class="headerlink" title="案例："></a>案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：求两个数的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span></span><br><span class="line">        <span class="comment">//注意点：</span></span><br><span class="line">        <span class="comment">//三元运算符的最终结果一定要被使用。</span></span><br><span class="line">        <span class="comment">//要么赋值给一个变量，要么直接输出。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span>  a &gt; b ? a : b ;</span><br><span class="line">        System.out.println(max);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a &gt; b ? a : b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-练习1-两只老虎"><a href="#17-练习1-两只老虎" class="headerlink" title="17.练习1-两只老虎"></a>17.练习1-两只老虎</h1><p>需求：</p><p>​动物园里有两只老虎，两只老虎的体重分别为通过键盘录入获得，</p><p>​请用程序实现判断两只老虎的体重是否相同。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取两只老虎的体重</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一只老虎的体重&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">weight1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第二只老虎的体重&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">weight2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用三元运算符求出最终结果</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> weight1 == weight2 ? <span class="string">&quot;相同&quot;</span> : <span class="string">&quot;不相同&quot;</span>;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h1 id="18-练习2-求三个数的最大值"><a href="#18-练习2-求三个数的最大值" class="headerlink" title="18.练习2-求三个数的最大值"></a>18.练习2-求三个数的最大值</h1><p>需求：</p><p>​一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm。</p><p>​请用程序实现获取这三个和尚的最高身高。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义三个变量记录和尚的身高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用三元运算符求出两个数中的较大值。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.求出最终的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> temp &gt; height3 ? temp : height3;</span><br><span class="line"></span><br><span class="line">System.out.println(max);</span><br></pre></td></tr></table></figure><h1 id="19-运算符的优先级"><a href="#19-运算符的优先级" class="headerlink" title="19.运算符的优先级"></a>19.运算符的优先级</h1><p>在Java中涉及了很多的运算符，每一种运算符都有各自的优先级。但是这些优先级不需要记忆。</p><p>咱们只要知道其中一点：</p><p>​小括号优先于所有。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的基础</title>
      <link href="/2020/01/01/java/day01-Java%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/01/01/java/day01-Java%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的基础介绍"><a href="#Java的基础介绍" class="headerlink" title="Java的基础介绍"></a>Java的基础介绍</h1><h2 id="1、java的开发流程"><a href="#1、java的开发流程" class="headerlink" title="1、java的开发流程"></a>1、java的开发流程</h2><p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p><p>​编译文件。编译后会产生一个class文件。</p><p>​java文件：程序员自己编写的代码。</p><p>​class文件：交给计算机执行的文件。</p><p>运行代码</p><p><strong>注意</strong>：运行的是编译之后的class文件。</p><h2 id="2-、HelloWorld常见问题"><a href="#2-、HelloWorld常见问题" class="headerlink" title="2 、HelloWorld常见问题"></a>2 、HelloWorld常见问题</h2><p>2.1、非法字符问题。Java中的符号都是英文格式的。</p><p>2.2、大小写问题。Java语言对大小写敏感（区分大小写）。</p><p>2.3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。</p><p>2.4、编译命令后的java文件名需要带文件后缀.java</p><p>2.5、运行命令后的class文件名（类名）不带文件后缀.class</p><h2 id="3、环境变量"><a href="#3、环境变量" class="headerlink" title="3、环境变量"></a>3、环境变量</h2><h4 id="3-1为什么配置环境变量"><a href="#3-1为什么配置环境变量" class="headerlink" title="3.1为什么配置环境变量"></a>3.1为什么配置环境变量</h4><p>​开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。</p><p>注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。</p><h2 id="4、-Java的三大平台"><a href="#4、-Java的三大平台" class="headerlink" title="4、 Java的三大平台"></a>4、 Java的三大平台</h2><p>JavaSE、JavaME、JavaEE</p><p>JavaSE是其他两个版本的基础。</p><h4 id="4-1-JavaME"><a href="#4-1-JavaME" class="headerlink" title="4.1 JavaME"></a>4.1 JavaME</h4><p>​Java语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p><p>​其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p><p>​但是，安卓也是可以用Java来开发的。</p><h4 id="4-2-JavaEE"><a href="#4-2-JavaEE" class="headerlink" title="4.2 JavaEE"></a>4.2 JavaEE</h4><p>​用于Web方向的网站开发。（主要从事后台服务器的开发）</p><p>​在服务器领域，Java是当之无愧的龙头老大。</p><h2 id="5、-Java的主要特性"><a href="#5、-Java的主要特性" class="headerlink" title="5、 Java的主要特性"></a>5、 Java的主要特性</h2><ul><li>面向对象</li><li>安全性</li><li>多线程</li><li>简单易用</li><li>开源</li><li>跨平台</li></ul><h4 id="5-1-Java语言跨平台的原理"><a href="#5-1-Java语言跨平台的原理" class="headerlink" title="5.1 Java语言跨平台的原理"></a>5.1 Java语言跨平台的原理</h4><ul><li>操作系统本身其实是不认识Java语言的。</li><li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li></ul><p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p><h2 id="6、-JRE和JDK"><a href="#6、-JRE和JDK" class="headerlink" title="6、 JRE和JDK"></a>6、 JRE和JDK</h2><p>JVM（Java Virtual Machine），Java虚拟机</p><p>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</p><p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p><p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的语法</title>
      <link href="/2019/02/01/java/day02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/02/01/java/day02-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><h2 id="一、关键字"><a href="#一、关键字" class="headerlink" title="一、关键字"></a>一、关键字</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>​被Java赋予了特定含义的英文单词。</p><table><thead><tr><th><strong>abstract</strong></th><th><strong>assert</strong></th><th><strong>boolean</strong></th><th><strong>break</strong></th><th><strong>byte</strong></th></tr></thead><tbody><tr><td><strong>case</strong></td><td><strong>catch</strong></td><td><strong>char</strong></td><td><strong>class</strong></td><td><strong>const</strong></td></tr><tr><td><strong>continue</strong></td><td><strong>default</strong></td><td><strong>do</strong></td><td><strong>double</strong></td><td><strong>else</strong></td></tr><tr><td><strong>enum</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>finally</strong></td><td><strong>float</strong></td></tr><tr><td><strong>for</strong></td><td><strong>goto</strong></td><td><strong>if</strong></td><td><strong>implements</strong></td><td><strong>import</strong></td></tr><tr><td><strong>instanceof</strong></td><td><strong>int</strong></td><td><strong>interface</strong></td><td><strong>long</strong></td><td><strong>native</strong></td></tr><tr><td><strong>new</strong></td><td><strong>package</strong></td><td><strong>private</strong></td><td><strong>protected</strong></td><td><strong>public</strong></td></tr><tr><td><strong>return</strong></td><td><strong>strictfp</strong></td><td><strong>short</strong></td><td><strong>static</strong></td><td><strong>super</strong></td></tr><tr><td><strong>switch</strong></td><td><strong>synchronized</strong></td><td><strong>this</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td></tr><tr><td><strong>transient</strong></td><td><strong>try</strong></td><td><strong>void</strong></td><td><strong>volatile</strong></td><td><strong>while</strong></td></tr></tbody></table><h3 id="1-2-第一个关键字class"><a href="#1-2-第一个关键字class" class="headerlink" title="1.2 第一个关键字class"></a>1.2 第一个关键字class</h3><p>​表示定义一个类。创建一个类。</p><p>类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。</p><p>class后面跟随的就是这个类的名字，简称：类名。</p><p>在类名后面会有一对大括号，表示这个类的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：class表示定义类。</p><p>​类名：HelloWorld</p><p>​HelloWorld后面的大括号表示这个类的范围。</p><h2 id="2、-字面量"><a href="#2、-字面量" class="headerlink" title="2、 字面量"></a>2、 字面量</h2><p>作用：告诉程序员，数据在程序中的书写格式。</p><table><thead><tr><th><strong>字面量类型</strong></th><th><strong>说明</strong></th><th><strong>程序中的写法</strong></th></tr></thead><tbody><tr><td>整数</td><td>不带小数的数字</td><td>666，-88</td></tr><tr><td>小数</td><td>带小数的数字</td><td>13.14，-5.21</td></tr><tr><td>字符</td><td>必须使用单引号，有且仅能一个字符</td><td>‘A’，‘0’，   ‘我’</td></tr><tr><td>字符串</td><td>必须使用双引号，内容可有可无</td><td>“HelloWorld”，“黑马程序员”</td></tr><tr><td>布尔值</td><td>布尔值，表示真假，只有两个值：true，false</td><td>true 、false</td></tr><tr><td>空值</td><td>一个特殊的值，空值</td><td>值是：null</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">10</span>); <span class="comment">// 输出一个整数</span></span><br><span class="line">        System.out.println(<span class="number">5.5</span>); <span class="comment">// 输出一个小数</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出一个字符</span></span><br><span class="line">        System.out.println(<span class="literal">true</span>); <span class="comment">// 输出boolean值true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎来到我的博客&quot;</span>); <span class="comment">// 输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分技巧"><a href="#区分技巧" class="headerlink" title="区分技巧"></a>区分技巧</h3><ol><li>不带小数点的数字都是整数类型的字面量。</li><li>只要带了小数点，那么就是小数类型的字面量。</li><li>只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。</li><li>字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。</li><li>字符类型的字面量只有两个值，true、false。</li><li>空类型的字面量只有一个值，null。</li></ol><h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><h3 id="3-1-什么是变量？"><a href="#3-1-什么是变量？" class="headerlink" title="3.1 什么是变量？"></a>3.1 什么是变量？</h3><p>​变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。</p><h3 id="3-2-变量的定义格式"><a href="#3-2-变量的定义格式" class="headerlink" title="3.2 变量的定义格式"></a>3.2 变量的定义格式</h3><p>​数据类型 变量名 &#x3D; 数据值； int a &#x3D; 3;</p><h4 id="3-2-1-格式详解"><a href="#3-2-1-格式详解" class="headerlink" title="3.2.1 格式详解"></a>3.2.1 格式详解</h4><p>​数据类型：限定了变量当中能存储什么类型的数据。</p><p>​   如果要存10，那么数据类型就需要写整数类型。</p><p>​   如果要存10.0，那么数据类型就需要写小数类型。</p><p>​变量名：其实就是这个容器的名字。</p><p>​当以后想要使用变量里面的数据时，直接使用变量名就可以了。</p><p>​数据值：真正存储在容器中的数据。</p><p>​分号：表示语句的结束，就跟以前写作文时候的句号是一样的。</p><h4 id="3-2-2-常用的数据类型"><a href="#3-2-2-常用的数据类型" class="headerlink" title="3.2.2 常用的数据类型"></a>3.2.2 常用的数据类型</h4><p>​整数：int</p><p>​小数：（浮点数）double</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//定义一个整数类型的变量</span></span><br><span class="line"><span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">System.out.println(a);<span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个小数类型的变量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line">System.out.println(b);<span class="comment">//10.1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-变量的注意事项"><a href="#3-2-3-变量的注意事项" class="headerlink" title="3.2.3 变量的注意事项"></a>3.2.3 变量的注意事项</h4><ul><li>变量名不能重复</li><li>在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。</li><li>变量在使用之前必须要赋值。</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDemo2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//1.变量名不允许重复</span></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int a = 20;</span></span><br><span class="line"><span class="comment">//System.out.println(a);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.一条语句可以定义多个变量</span></span><br><span class="line"><span class="comment">//了解。</span></span><br><span class="line"><span class="comment">//int a = 10, b = 20, c = 20,d = 20;</span></span><br><span class="line"><span class="comment">//System.out.println(a);//?</span></span><br><span class="line"><span class="comment">//System.out.println(b);//?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.变量在使用之前必须要赋值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、-数据类型"><a href="#4、-数据类型" class="headerlink" title="4、 数据类型"></a>4、 数据类型</h2><h3 id="4-1-Java语言数据类型的分类"><a href="#4-1-Java语言数据类型的分类" class="headerlink" title="4.1 Java语言数据类型的分类"></a>4.1 Java语言数据类型的分类</h3><ul><li>基本数据类型</li><li>引用数据类型（面向对象的时候再深入学习）</li></ul><h3 id="4-2-基本数据类型的四类八种"><a href="#4-2-基本数据类型的四类八种" class="headerlink" title="4.2 基本数据类型的四类八种"></a>4.2 基本数据类型的四类八种</h3><table><thead><tr><th align="center">数据类型</th><th align="center">关键字</th><th align="center">内存占用</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">整数</td><td align="center">byte</td><td align="center">1</td><td align="center">负的2的7次方 ~ 2的7次方-1(-128~127)</td></tr><tr><td align="center"></td><td align="center">short</td><td align="center">2</td><td align="center">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td></tr><tr><td align="center"></td><td align="center">int</td><td align="center">4</td><td align="center">负的2的31次方 ~ 2的31次方-1</td></tr><tr><td align="center"></td><td align="center">long</td><td align="center">8</td><td align="center">负的2的63次方 ~ 2的63次方-1</td></tr><tr><td align="center">浮点数</td><td align="center">float</td><td align="center">4</td><td align="center">1.401298e-45 ~ 3.402823e+38</td></tr><tr><td align="center"></td><td align="center">double</td><td align="center">8</td><td align="center">4.9000000e-324 ~ 1.797693e+308</td></tr><tr><td align="center">字符</td><td align="center">char</td><td align="center">2</td><td align="center">0-65535</td></tr><tr><td align="center">布尔</td><td align="center">boolean</td><td align="center">1</td><td align="center">true，false</td></tr></tbody></table><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>​e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。</p><p>​在java中整数默认是int类型，浮点数默认是double类型。</p><h4 id="需要记忆以下几点"><a href="#需要记忆以下几点" class="headerlink" title="需要记忆以下几点"></a>需要记忆以下几点</h4><p>byte类型的取值范围：</p><p>​-128 ~ 127</p><p>int类型的大概取值范围：</p><p>​-21亿多  ~ 21亿多</p><p>整数类型和小数类型的取值范围大小关系：</p><p>​double &gt; float &gt; long &gt; int &gt; short &gt; byte</p><p>最为常用的数据类型选择：</p><ul><li><p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p><p>比如：人的年龄，可以选择byte类型。</p><p>比如：地球的年龄，可以选择long类型。</p></li><li><p>如果整数类型中，不太确定范围，那么默认使用int类型。</p></li><li><p>如果小数类型中，不太确定范围，那么默认使用double类型。</p></li><li><p>如果要定义字符类型的变量，那么使用char</p></li><li><p>如果要定义布尔类型的变量，那么使用boolean</p></li></ul><h3 id="4-3-定义8种基本数据类型变量"><a href="#4-3-定义8种基本数据类型变量" class="headerlink" title="4.3 定义8种基本数据类型变量"></a>4.3 定义8种基本数据类型变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义byte类型的变量</span></span><br><span class="line">        <span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.定义short类型的变量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.定义int类型的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.定义long类型的变量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">123456789123456789L</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.定义float类型的变量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1F</span>;</span><br><span class="line">        System.out.println(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.定义double类型的变量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">20.3</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.定义char类型的变量</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">g</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(g);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.定义boolean类型的变量</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">h</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(h);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h4><ul><li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li><li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li><li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li><li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li></ul><h2 id="5、标识符"><a href="#5、标识符" class="headerlink" title="5、标识符"></a>5、标识符</h2><p>业内大多数程序员都在遵守阿里巴巴的命名规则。</p><h3 id="5-1-硬性要求："><a href="#5-1-硬性要求：" class="headerlink" title="5.1 硬性要求："></a>5.1 硬性要求：</h3><p>​必须要这么做，否则代码会报错。</p><ul><li>必须由数字、字母、下划线_、美元符号$组成。</li><li>数字不能开头</li><li>不能是关键字</li><li>区分大小写的。</li></ul><h3 id="5-2-软件建议："><a href="#5-2-软件建议：" class="headerlink" title="5.2 软件建议："></a>5.2 软件建议：</h3><p>​如果不这么做，代码不会报错，但是会让代码显得比较low。</p><h3 id="5-3-小驼峰命名法"><a href="#5-3-小驼峰命名法" class="headerlink" title="5.3 小驼峰命名法"></a>5.3 小驼峰命名法</h3><p>适用于变量名和方法名</p><ul><li><p>如果是一个单词，那么全部小写，比如：name</p></li><li><p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p></li><li><p><strong>(第二个单词)</strong></p></li></ul><h3 id="5-4大驼峰命名法"><a href="#5-4大驼峰命名法" class="headerlink" title="5.4大驼峰命名法"></a>5.4大驼峰命名法</h3><p>适用于类名</p><ul><li><p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p></li><li><p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p></li></ul><p>不管起什么名字，都要做到见名知意。</p><p><strong>方法名小写，类名大写</strong></p><h3 id="阿里巴巴命名规范细节："><a href="#阿里巴巴命名规范细节：" class="headerlink" title="阿里巴巴命名规范细节："></a>阿里巴巴命名规范细节：</h3><ol><li><p>尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。</p><p>正确：alibaba、hangzhou、nanjing</p><p>错误：jiage、dazhe</p></li><li><p>平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。</p><p>错误：_name</p><p>正确：name</p></li></ol><h2 id="7-键盘录入"><a href="#7-键盘录入" class="headerlink" title="7. 键盘录入"></a>7. 键盘录入</h2><p>​键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</p><p>使用步骤：</p><p>第一步：</p><p>​导包：其实就是表示先找到Scanner这个类在哪。</p><p>第二步：</p><p>​创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</p><p>第三步：</p><p>​接收数据：也是真正干活的代码。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包，其实就是先找到Scanner这个类在哪</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//3.接收数据</span></span><br><span class="line"><span class="comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-IDEA中层级结构介绍"><a href="#7-1-IDEA中层级结构介绍" class="headerlink" title="7.1 IDEA中层级结构介绍"></a>7.1 IDEA中层级结构介绍</h3><h4 id="7-1-结构分类"><a href="#7-1-结构分类" class="headerlink" title="7.1 结构分类"></a>7.1 结构分类</h4><ul><li>project（项目、工程）</li><li>module（模块）</li><li>package（包）</li><li>class（类）</li></ul><h4 id="7-2-结构介绍"><a href="#7-2-结构介绍" class="headerlink" title="7.2 结构介绍"></a>7.2 结构介绍</h4><p>​为了让大家更好的吸收，package这一层级，我们后面再学习，先学习最基础的project、module、class。</p><h5 id="project（项目、工程）"><a href="#project（项目、工程）" class="headerlink" title="project（项目、工程）"></a>project（项目、工程）</h5><p>​淘宝、京东、程序员网站都属于一个个项目，IDEA中就是一个个的Project。</p><h5 id="module（模块）"><a href="#module（模块）" class="headerlink" title="module（模块）"></a>module（模块）</h5><p>​在一个项目中，可以存放多个模块，不同的模块可以存放项目中不同的业务功能代码。在官方网站中，至少包含了以下模块：</p><ul><li>论坛模块</li><li>报名、咨询模块</li></ul><p>为了更好的管理代码，我们会把代码分别放在两个模块中存放。</p><h5 id="package（包）"><a href="#package（包）" class="headerlink" title="package（包）"></a>package（包）</h5><p>​一个模块中又有很多的业务，以官方网站的论坛模块为例，至少包含了以下不同的业务。</p><ul><li>发帖</li><li>评论</li></ul><p>为了把这些业务区分的更加清楚，就会用包来管理这些不同的业务。</p><h5 id="class（类）"><a href="#class（类）" class="headerlink" title="class（类）"></a>class（类）</h5><p>​就是真正写代码的地方。</p><h4 id="7-3-小结"><a href="#7-3-小结" class="headerlink" title="7.3 小结"></a>7.3 小结</h4><ul><li><p>层级关系</p><p>​project - module - package - class</p></li><li><p>包含数量</p><p>​project中可以创建多个module<br>​module中可以创建多个package<br>​package中可以创建多个class</p><p>​这些结构的划分，是为了方便管理类文件的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
